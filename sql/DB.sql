-- MySQL dump 10.13  Distrib 5.5.27, for Win32 (x86)
--
-- Host: localhost    Database: haechi
-- ------------------------------------------------------
-- Server version	6.0.0-alpha-community-nt-debug

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `contracts`
--

DROP TABLE IF EXISTS `contracts`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `contracts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `code` text,
  `ip` varchar(64) DEFAULT NULL,
  `createdate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `contracts`
--

LOCK TABLES `contracts` WRITE;
/*!40000 ALTER TABLE `contracts` DISABLE KEYS */;
INSERT INTO `contracts` VALUES (28,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-12 23:45:50'),(29,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-12 23:49:46'),(30,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-12 23:50:57'),(31,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public \n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-12 23:54:53'),(32,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-12 23:56:21'),(33,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-12 23:56:30'),(34,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n','0:0:0:0:0:0:0:1','2019-11-12 23:57:32'),(35,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n','0:0:0:0:0:0:0:1','2019-11-13 00:08:19'),(36,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-13 00:09:48'),(37,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 16:27:12'),(38,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 16:34:32'),(39,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 16:34:34'),(40,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 19:23:08'),(41,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 19:23:27'),(42,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) \n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 19:37:59'),(43,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 19:42:55'),(44,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public \n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 19:44:09'),(45,'pragma solidity >=0.4.22 <0.6.0;\ncontract Ballot {\n\n    struct Voter {\n        uint weight;\n        bool voted;\n        uint8 vote;\n        address delegate;\n    }\n    struct Proposal {\n        uint voteCount;\n    }\n\n    address chairperson;\n    mapping(address => Voter) voters;\n    Proposal[] proposals;\n\n    /// Create a new ballot with $(_numProposals) different proposals.\n    constructor(uint8 _numProposals) public {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n        proposals.length = _numProposals;\n    }\n\n    /// Give $(toVoter) the right to vote on this ballot.\n    /// May only be called by $(chairperson).\n    function giveRightToVote(address toVoter) public {\n        if (msg.sender != chairperson || voters[toVoter].voted) return;\n        voters[toVoter].weight = 1;\n    }\n\n    /// Delegate your vote to the voter $(to).\n    function delegate(address to) public {\n        Voter storage sender = voters[msg.sender]; // assigns reference\n        if (sender.voted) return;\n        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)\n            to = voters[to].delegate;\n        if (to == msg.sender) return;\n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegateTo = voters[to];\n        if (delegateTo.voted)\n            proposals[delegateTo.vote].voteCount += sender.weight;\n        else\n            delegateTo.weight += sender.weight;\n    }\n\n    /// Give a single vote to proposal $(toProposal).\n    function vote(uint8 toProposal) public {\n        Voter storage sender = voters[msg.sender];\n        if (sender.voted || toProposal >= proposals.length) return;\n        sender.voted = true;\n        sender.vote = toProposal;\n        proposals[toProposal].voteCount += sender.weight;\n    }\n\n    function winningProposal() public view returns (uint8 _winningProposal) {\n        uint256 winningVoteCount = 0;\n        for (uint8 prop = 0; prop < proposals.length; prop++)\n            if (proposals[prop].voteCount > winningVoteCount) \n                winningVoteCount = proposals[prop].voteCount;\n                _winningProposal = prop;\n            }\n    }\n}\n','0:0:0:0:0:0:0:1','2019-11-17 19:44:45'),(46,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public \n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 19:52:13'),(47,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 22:01:55'),(48,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 22:23:25'),(49,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 22:27:06'),(50,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 22:29:12'),(51,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 22:31:52'),(52,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 22:32:37'),(53,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 22:34:37'),(54,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 22:35:22'),(55,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:29:11'),(56,'pragma solidity^0.4.18;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint z;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++; b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    //function testDoWhile() public {\n    //    i = 10;\n    //    do {\n    //        i--;\n    //        a = 10;\n    //    } while(i > 0);\n    //}\n}\n\n','0:0:0:0:0:0:0:1','2019-11-17 23:32:48'),(57,'pragma solidity^0.4.18;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint z;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++; b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    //function testDoWhile() public {\n    //    i = 10;\n    //    do {\n    //        i--;\n    //        a = 10;\n    //    } while(i > 0);\n    //}\n}\n\n','0:0:0:0:0:0:0:1','2019-11-17 23:37:36'),(58,'pragma solidity^0.4.18;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint z;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++; b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    //function testDoWhile() public {\n    //    i = 10;\n    //    do {\n    //        i--;\n    //        a = 10;\n    //    } while(i > 0);\n    //}\n}\n\n','0:0:0:0:0:0:0:1','2019-11-17 23:37:57'),(59,'pragma solidity^0.4.18;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint z;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++; b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    //function testDoWhile() public {\n    //    i = 10;\n    //    do {\n    //        i--;\n    //        a = 10;\n    //    } while(i > 0);\n    //}\n}\n\n','0:0:0:0:0:0:0:1','2019-11-17 23:39:43'),(60,'pragma solidity^0.4.18;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint z;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++; b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    //function testDoWhile() public {\n    //    i = 10;\n    //    do {\n    //        i--;\n    //        a = 10;\n    //    } while(i > 0);\n    //}\n}\n\n','0:0:0:0:0:0:0:1','2019-11-17 23:40:23'),(61,'pragma solidity^0.4.18;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint z;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++; b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    //function testDoWhile() public {\n    //    i = 10;\n    //    do {\n    //        i--;\n    //        a = 10;\n    //    } while(i > 0);\n    //}\n}\n\n','0:0:0:0:0:0:0:1','2019-11-17 23:41:28'),(62,'pragma solidity^0.4.18;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint z;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++; b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    //function testDoWhile() public {\n    //    i = 10;\n    //    do {\n    //        i--;\n    //        a = 10;\n    //    } while(i > 0);\n    //}\n}\n\n','0:0:0:0:0:0:0:1','2019-11-17 23:42:13'),(63,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:45:05'),(64,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:48:26'),(65,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:48:29'),(66,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:50:27'),(67,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:50:39'),(68,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:50:46'),(69,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:51:20'),(70,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:51:24'),(71,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:51:27'),(72,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:53:08'),(73,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:53:15'),(74,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:55:02'),(75,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:55:05'),(76,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-17 23:55:36'),(77,'pragma solidity^0.4.18;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint z;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++; b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    //function testDoWhile() public {\n    //    i = 10;\n    //    do {\n    //        i--;\n    //        a = 10;\n    //    } while(i > 0);\n    //}\n}\n\n','0:0:0:0:0:0:0:1','2019-11-18 03:02:45'),(78,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 10:41:11'),(79,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:10:03'),(80,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:16:23'),(81,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:24:20'),(82,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:27:24'),(83,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:31:47'),(84,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:34:31'),(85,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:36:01'),(86,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:46:41'),(87,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:49:53'),(88,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:53:52'),(89,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:55:57'),(90,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:58:56'),(91,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 11:59:45'),(92,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 12:00:02'),(93,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 12:01:56'),(94,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 12:04:25'),(95,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 12:04:39'),(96,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 12:05:27'),(97,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 12:06:14'),(98,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 12:06:21'),(99,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 12:08:26'),(100,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 12:09:00'),(101,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 13:04:53'),(102,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 13:05:39'),(103,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 13:05:46'),(104,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 13:06:27'),(105,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 13:09:45'),(106,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 13:10:51'),(107,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 13:23:22'),(108,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 13:58:54'),(109,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:06:45'),(110,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:14:18'),(111,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:15:51'),(112,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:16:36'),(113,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:18:34'),(114,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:19:40'),(115,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:26:12'),(116,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:26:20'),(117,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:30:20'),(118,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:30:23'),(119,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:46:41'),(120,'pragma solidity^0.4.18;\n\ncontract OverflowUnderflow {\n  address addr = msg.sender;\n  uint value = 1;\n  function increment() public {\n    value = value + 1;\n  }\n  function decrement() public {\n    value = value - 1;\n  }\n}\n\n','0:0:0:0:0:0:0:1','2019-11-20 14:49:04'),(121,'pragma solidity^0.4.18;\n\ncontract OverflowUnderflow {\n  address addr = msg.sender;\n  uint value = 1;\n  function increment() public {\n    value = value + 1;\n  }\n  function decrement() public {\n    value = value - 1;\n  }\n}\n\n','0:0:0:0:0:0:0:1','2019-11-20 14:52:01'),(122,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:52:35'),(123,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:52:51'),(124,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 14:53:29'),(125,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 15:07:09'),(126,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 15:25:38'),(127,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 15:28:07'),(128,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 16:31:45'),(129,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 16:35:10'),(130,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 16:35:58'),(131,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 16:36:30'),(132,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 16:36:50'),(133,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 16:38:52'),(134,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 17:16:00'),(135,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 17:24:27'),(136,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 17:29:12'),(137,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 17:31:01'),(138,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 17:33:41'),(139,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 17:34:09'),(140,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 17:34:16'),(141,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 17:34:24'),(142,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 17:38:47'),(143,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 17:42:23'),(144,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 17:49:23'),(145,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:19:03'),(146,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:23:25'),(147,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:35:24'),(148,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:35:42'),(149,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:36:13'),(150,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:45:40'),(151,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:48:52'),(152,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:50:53'),(153,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:51:47'),(154,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:55:06'),(155,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 18:59:12'),(156,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:00:12'),(157,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:00:52'),(158,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:01:08'),(159,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:05:30'),(160,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:06:52'),(161,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:09:20'),(162,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:11:38'),(163,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:13:31'),(164,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','0:0:0:0:0:0:0:1','2019-11-20 19:19:23'),(165,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:43:27'),(166,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 19:45:20'),(167,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:46:47'),(168,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:49:16'),(169,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:51:20'),(170,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:55:01'),(171,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:55:23'),(172,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:56:45'),(173,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 19:56:50'),(174,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 19:57:00'),(175,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 20:01:17'),(176,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 20:02:27'),(177,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 20:02:52'),(178,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 20:03:06'),(179,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 20:12:50'),(180,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 20:13:07'),(181,'pragma solidity^0.4.18;\n\ncontract Auction {\n    address currentLeader;\n    uint highestBid;\n\n    function bid() payable {\n        require(msg.value > highestBid);\n\n        require(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert\n\n        currentLeader = msg.sender;\n        highestBid = msg.value;\n    }\n}\n','0:0:0:0:0:0:0:1','2019-11-20 20:33:11'),(182,'pragma solidity^0.4.18;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 5;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 20:34:28'),(183,'pragma solidity^0.4.18;\n\ncontract Fund {\n    /// Mapping of ether shares of the contract.\n    mapping(address => uint) shares;\n    \n    /// Withdraw your share.\n    function withdraw() public {\n        if (msg.sender.send(shares[msg.sender]))\n            shares[msg.sender] = 0;\n    }\n}		','0:0:0:0:0:0:0:1','2019-11-20 20:35:26'),(184,'pragma solidity^0.4.18;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n    \n  function donate(address to) payable public{\n    credit[to] += msg.value;\n  }\n    \n  function withdraw(uint amount) public{\n    if (credit[msg.sender]>= amount) {\n      require(msg.sender.call.value(amount)());\n      credit[msg.sender]-=amount;\n    }\n  }  \n  \n}	','0:0:0:0:0:0:0:1','2019-11-20 20:36:04'),(185,'pragma solidity^0.4.18;\n\ncontract MyContract {\n\n    address owner;\n\n    function sendTo(address receiver, uint amount) public {\n        require(tx.origin == owner);\n        receiver.transfer(amount);\n    }\n\n    function MyContract() public {\n        owner = msg.sender;\n    }\n}		','0:0:0:0:0:0:0:1','2019-11-20 20:36:33'),(186,'pragma solidity^0.4.18;\n\ncontract owned {\n    function owned() public {\n        owner = msg.sender;\n    }\n    address owner;\n}\n\ncontract mortal is owned {\n    function kill() public {\n        if (msg.sender == owner) {\n            selfdestruct(owner);\n        }\n    }\n}\n\ncontract Base1 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Base2 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Final is Base1, Base2 {\n    \n}','0:0:0:0:0:0:0:1','2019-11-20 20:36:51'),(187,'contract owned {\n    function owned() public {\n        owner = msg.sender;\n    }\n    address owner;\n}\n\ncontract mortal is owned {\n    function kill() public {\n        if (msg.sender == owner) {\n            selfdestruct(owner);\n        }\n    }\n}\n\ncontract Base1 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Base2 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Final is Base1, Base2 {\n    \n}','0:0:0:0:0:0:0:1','2019-11-20 20:37:26'),(188,'contract owned {\n    function owned() public {\n        owner = msg.sender;\n    }\n    address owner;\n}\n\ncontract mortal is owned {\n    function kill() public {\n        if (msg.sender == owner) {\n            selfdestruct(owner);\n        }\n    }\n}\n\ncontract Base1 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Base2 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Final is Base1, Base2 {\n    \n}','192.168.0.1','2019-11-20 20:37:39'),(189,'contract owned {\n    function owned() public {\n        owner = msg.sender;\n    }\n    address owner;\n}\n\ncontract mortal is owned {\n    function kill() public {\n        if (msg.sender == owner) {\n            selfdestruct(owner);\n        }\n    }\n}\n\ncontract Base1 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Base2 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Final is Base1, Base2 {\n    \n}','192.168.0.1','2019-11-20 20:38:04'),(190,'pragma solidity^0.4.18;\n\ncontract owned {\n    function owned() public {\n        owner = msg.sender;\n    }\n    address owner;\n}\n\ncontract mortal is owned {\n    function kill() public {\n        if (msg.sender == owner) {\n            selfdestruct(owner);\n        }\n    }\n}\n\ncontract Base1 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Base2 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Final is Base1, Base2 {\n    \n}','192.168.0.1','2019-11-20 20:38:44'),(191,'pragma solidity^0.4.18;\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}','192.168.0.1','2019-11-20 20:44:55'),(192,'pragma solidity^0.4.18;\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract MyContract {\n\n    address owner;\n\n    function sendTo(address receiver, uint amount) public {\n        require(tx.origin == owner);\n        receiver.transfer(amount);\n    }\n\n    function MyContract() public {\n        owner = msg.sender;\n    }\n}	','192.168.0.1','2019-11-20 20:45:37'),(193,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}','192.168.0.1','2019-11-20 20:46:38'),(194,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 20:47:51'),(195,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 20:48:17'),(196,'pragma solidity^0.4.18;\n\ncontract MyContract {\n\n    address owner;\n\n    function sendTo(address receiver, uint amount) public {\n        require(tx.origin == owner);\n        receiver.transfer(amount);\n    }\n\n    function MyContract() public {\n        owner = msg.sender;\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 20:51:25'),(197,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','0:0:0:0:0:0:0:1','2019-11-20 20:52:15'),(198,'pragma solidity ^0.4.18;\n\ncontract Ballot {\n  struct Voter {\n    uint weight;\n    bool voted;\n    address delegate;\n    uint vote;\n  }\n\n  struct Proposal {\n    bytes32 name;\n    uint voteCount;\n  }\n\n  address public chairperson;\n\n  // declare a state variable that stores a voter struct for each\n  // possible address\n  mapping(address => Voter) public voters;\n\n  Proposal[] public proposals;\n\n  constructor (bytes32[] memory proposalNames) public {\n    chairperson = msg.sender;\n    voters[chairperson].weight = 1;\n    for (uint i = 0; i < proposalNames.length; i++) {\n      createProposal(proposalNames[i]);\n    }\n  }\n\n  function createProposal (bytes32 proposalName) public {\n    require(msg.sender == chairperson);\n    proposals.push(Proposal({\n      name: proposalName,\n      voteCount: 0\n    }));\n\n  }\n\n  function getProposalsCount() public view returns (uint)  {\n    return proposals.length;\n  }\n\n  function getVoterWeight (address voter) view public returns (uint)  {\n    return voters[voter].weight;\n  }\n\n  function giveRightToVote(address voter) public {\n    require(msg.sender == chairperson);\n    require(!voters[voter].voted);\n    require(voters[voter].weight == 0);\n\n    voters[voter].weight = 1;\n  }\n\n  function delegate(address to) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n\n    require(to != msg.sender);\n\n    // iterate until we find an entry with an empty address entry\n    while (voters[to].delegate != address(0)) {\n      to = voters[to].delegate;\n      require(to != msg.sender);\n    }\n\n    sender.voted = true;\n    sender.delegate = to;\n\n    Voter storage delegate_to = voters[to];\n    if (delegate_to.voted) {\n      proposals[delegate_to.vote].voteCount += sender.weight;\n    } else {\n      delegate_to.weight += sender.weight;\n    }\n  }\n\n  function vote (uint proposal) public {\n    Voter storage sender = voters[msg.sender];\n    require(!sender.voted);\n    sender.voted = true;\n    sender.vote = proposal;\n\n    proposals[proposal].voteCount += sender.weight;\n  }\n\n  function winningProposal() view public returns (uint winner) {\n    uint winningVoteCount = 0;\n    for (uint p = 0; p < proposals.length; p ++) {\n      if (proposals[p].voteCount > winningVoteCount) {\n        winningVoteCount = proposals[p].voteCount;\n        winner = p;\n      }\n    }\n  }\n\n  function winnerName() view public returns (bytes32 name) {\n    name = proposals[winningProposal()].name;\n  }\n\n  function getProposalName(uint index) public view returns (bytes32) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].name;\n  }\n\n  function getProposalVoteCount(uint index) public view returns (uint) {\n    require(index < proposals.length);\n    require(index >= 0);\n    return proposals[index].voteCount;\n  }\n}','192.168.0.1','2019-11-20 20:52:51'),(199,'pragma solidity ^0.4.18;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 5;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n}','192.168.0.1','2019-11-20 20:53:13'),(200,'pragma solidity ^0.4.25;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 5;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 20:53:56'),(201,'pragma solidity ^0.4.25;\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 5;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n}','192.168.0.1','2019-11-20 20:54:30'),(202,'pragma solidity ^0.4.25;\n\ncontract Fund {\n    /// Mapping of ether shares of the contract.\n    mapping(address => uint) shares;\n    \n    /// Withdraw your share.\n    function withdraw() public {\n        if (msg.sender.send(shares[msg.sender]))\n            shares[msg.sender] = 0;\n    }\n}','192.168.0.1','2019-11-20 20:54:54'),(203,'pragma solidity ^0.4.25;\n\ncontract Fund {\n    /// Mapping of ether shares of the contract.\n    mapping(address => uint) shares;\n    \n    /// Withdraw your share.\n    function withdraw() public {\n        if (msg.sender.send(shares[msg.sender]))\n            shares[msg.sender] = 0;\n    }\n}','192.168.0.1','2019-11-20 20:55:39'),(204,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 20:56:37'),(205,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 20:56:56'),(206,'pragma solidity ^0.4.25;\n\ncontract Mallory {\n  SimpleDAO dao;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n','0:0:0:0:0:0:0:1','2019-11-20 20:58:45'),(207,'pragma solidity ^0.4.25;\n\ncontract Mallory {\n  SimpleDAO dao;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n','192.168.0.1','2019-11-20 20:59:11'),(208,'pragma solidity ^0.4.25;\ncontract Mallory {\n  SimpleDAO dao;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n','192.168.0.1','2019-11-20 20:59:33'),(209,'pragma solidity ^0.4.25;\ncontract Mallory {\n  SimpleDAO dao;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n','192.168.0.1','2019-11-20 21:00:09'),(210,'pragma solidity ^0.4.25;\n\ncontract Mallory {\n    SimpleDAO dao;\n    mapping (address => uint) userBalance;\n\n    function func() public {\n        dao.withdraw();\n    }\n    function() external { \n        dao.withdraw();\n    }\n    function testFunc() public {\n        dao.withdraw();\n        func();\n    }\n    function notitle() public {\n        dao.withdraw();\n    }\n    function getBalance(address u) public view returns(uint){\n        return userBalance[u];\n    }\n}\n\ncontract SimpleDAO {\n    Mallory mallory;\n    mapping (address => uint) public credit;\n\n    function withdraw() public {\n        Mallory mal;\n        address adrr;\n        mallory.testFunc(); \n        mal.func();\n        adrr = tx.origin;\n    }\n}\n','192.168.0.1','2019-11-20 21:02:39'),(211,'pragma solidity ^0.4.25;\n\ncontract Mallory {\n    SimpleDAO dao;\n    mapping (address => uint) userBalance;\n    function func() public {\n        dao.withdraw();\n    }\n    function() external { \n        dao.withdraw();\n    }\n    function testFunc() public {\n        dao.withdraw();\n        func();\n    }\n    function notitle() public {\n        dao.withdraw();\n    }\n    function getBalance(address u) public view returns(uint){\n        return userBalance[u];\n    }\n}\n\ncontract SimpleDAO {\n    Mallory mallory;\n    mapping (address => uint) public credit;\n\n    function withdraw() public {\n        Mallory mal;\n        address adrr;\n        mallory.testFunc(); \n        mal.func();\n        adrr = tx.origin;\n    }\n}\n','192.168.0.1','2019-11-20 21:03:12'),(212,'pragma solidity ^0.4.25;\n\ncontract Mallory {\n    SimpleDAO dao;\n    mapping (address => uint) userBalance;\n\n    function func() public {\n        dao.withdraw();\n    }\n    function() external { \n        dao.withdraw();\n    }\n    function testFunc() public {\n        dao.withdraw();\n        func();\n    }\n    function notitle() public {\n        dao.withdraw();\n    }\n    function getBalance(address u) public view returns(uint){\n        return userBalance[u];\n    }\n}\n\ncontract SimpleDAO {\n    Mallory mallory;\n    mapping (address => uint) public credit;\n\n    function withdraw() public {\n        Mallory mal;\n        address adrr;\n        mallory.testFunc(); \n        mal.func();\n        adrr = tx.origin;\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 21:03:54'),(213,'pragma solidity ^0.4.25;\n\ncontract Mallory {\n    SimpleDAO dao;\n    mapping (address => uint) userBalance;\n    function func() public {\n        dao.withdraw();\n    }\n    function() external { \n        dao.withdraw();\n    }\n    function testFunc() public {\n        dao.withdraw();\n        func();\n    }\n    function notitle() public {\n        dao.withdraw();\n    }\n    function getBalance(address u) public view returns(uint){\n        return userBalance[u];\n    }\n}\n\ncontract SimpleDAO {\n    Mallory mallory;\n    mapping (address => uint) public credit;\n\n    function withdraw() public {\n        Mallory mal;\n        address adrr;\n        mallory.testFunc(); \n        mal.func();\n        adrr = tx.origin;\n    }\n}\n','192.168.0.1','2019-11-20 21:04:28'),(214,'pragma solidity^0.4.18;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n    \n  function donate(address to) payable public{\n    credit[to] += msg.value;\n  }\n    \n  function withdraw(uint amount) public{\n    if (credit[msg.sender]>= amount) {\n      require(msg.sender.call.value(amount)());\n      credit[msg.sender]-=amount;\n    }\n  }  \n  \n}','192.168.0.1','2019-11-20 21:06:08'),(215,'pragma solidity^0.4.25;\n\ncontract TxUserWallet {\n\n    address owner;\n\n    function TxUserWallet() public {\n        owner = msg.sender;\n    }\n\n    function transferTo(address dest, uint amount) public {\n        require(tx.origin == owner);\n        dest.transfer(amount);\n    }\n}\n','192.168.0.1','2019-11-20 21:07:17'),(216,'pragma solidity^0.4.25;\n\ncontract owned {\n    function owned() public {\n        owner = msg.sender;\n    }\n    address owner;\n}\n\ncontract mortal is owned {\n    function kill() public {\n        if (msg.sender == owner) {\n            selfdestruct(owner);\n        }\n    }\n}\n\ncontract Base1 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Base2 is mortal {\n    function kill() public {\n        super.kill();\n    }\n}\n\ncontract Final is Base1, Base2 {\n    \n}','192.168.0.1','2019-11-20 21:08:07'),(217,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 21:16:11'),(218,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 21:16:13'),(219,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 21:16:15'),(220,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 21:16:16'),(221,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 21:16:16'),(222,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 21:16:17'),(223,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 21:16:18'),(224,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 21:18:10'),(225,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 21:18:58'),(226,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','192.168.0.1','2019-11-20 21:20:27'),(227,'pragma solidity^0.4.18;\n\ncontract Mallory {\n  SimpleDAO dao;\n  testContract test;\n  mapping (address => uint) userBalance;\n\n  function func() public {\n    dao.withdraw();\n  }\n  function() external { \n    dao.withdraw();\n  }\n  function testFunc() public {\n    dao.withdraw();\n    func();\n   test.testFunc2();\n  }\n  function notitle() public {\n      dao.withdraw();\n  }\n  function getBalance(address u) public view returns(uint){\n    return userBalance[u];\n  }\n}\n \ncontract SimpleDAO {\n  Mallory mallory;\n  mapping (address => uint) public credit;\n\n  function withdraw() public {\n    Mallory mal;\n    address adrr;\n    mallory.testFunc(); \n    mal.func();\n    adrr = tx.origin;\n  }\n}\n\ncontract testContract {\n  SimpleDAO simple;\n  function testFunc2() public {\n      simple.withdraw();\n  }\n}\n\ncontract TxOriginContract {\n    address owner;\n    uint c;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function send(uint amount) public payable{\n        msg.sender.send(msg.value);\n        require(tx.origin == owner);\n        tx.origin.send(amount);\n    }\n\n    function transfer(uint amount) public payable{\n        msg.sender.transfer(amount);\n        require(tx.origin == owner);\n        tx.origin.send(msg.value);\n    }\n}\n\ncontract ownedContract {\n    uint a;\n    function get() public view returns(uint) {\n        return a;\n    }\n}\n\ncontract BaseNo1 is ownedContract {\n    function set() public {\n        a = 1;\n    }\n    function set(uint num, uint num2) public {\n        a = num;\n    }\n}\n\ncontract BaseNo2 is ownedContract {\n    function set() public {\n        a = 2;\n    }\n\n    function set(uint num, uint num2) public {\n        a = num ;\n    }\n    function set2() public {\n        a = 10;\n    }\n}\n\ncontract Final is BaseNo1, BaseNo2 {\n    function set() public {\n       a = 3;\n    }\n    function func() public {\n        set();\n        set(10, 10);\n        super.set();\n    }\n}\n\ncontract Empty is Final {\n\n}\n\ncontract Temp is Empty{\n    uint a;\n\n    function set(uint num) public {\n       a = 3;\n    }\n\n    function set() public {\n      a = 3;\n    }\n}\n\ncontract Test is Final, Temp {\n    function test() public {\n        set(10, 20);\n    }\n}\n\n\ncontract OverflowUnderflow {\n  \n  function increment() public {\n    uint a = 10;\n    uint b = 1 + 2 * 3 - 4;\n    uint c = 1 + 2;\n    uint max = 500;\n    max = 501;\n    max += 1;\n    max = b - 1;\n    max = c + 1 - 2 - 3;\n    max = 12 % 5;\n    max -= 1;\n    max = max * 2;\n    max *= 3;\n    max /= 2;\n    max = max / 3;\n    max++;\n    ++max;\n    max--;\n    max ** 2;\n    --max;\n    if(a >= 10) {\n      max = 490;\n      max = max + 99;\n    }\n\n    if(c >= 30) {\n      c = a * 3 + 10;\n    }\n  }\n}\n\ncontract Contract1 {\n    uint a;\n\n    function set() public {\n        a = 1;\n    }\n\n    function set(uint num) public {\n        a = num;\n    }\n}\n\ncontract Contract2 {\n    uint a;\n    uint b;\n    function set(uint num, uint num2) public {\n       a = num; \n       b = num2;\n    }\n}\n\ncontract Test2 is Contract1, Contract2 {\n    function test() public {\n        set(10, 20);\n    }\n}\n\ncontract TestLoop {\n    address owner = msg.sender;\n    uint i = 2;\n    uint a = 2;\n    uint b = 3;\n    uint c = 0;\n\n    function testWhile(uint amount) public{\n        while(i > 0) {\n            require(tx.origin == owner);\n            msg.sender.transfer(amount);\n            i--;\n        }\n    }\n\n    function testForStatement(uint amount) public {\n        require(tx.origin == owner);\n        for(i=0; i<10; i++) {\n            a++;\n            b++;\n            for(uint k=0; k<5; k++) {\n                msg.sender.send(amount);\n                msg.sender.transfer(amount);\n                require(tx.origin == owner);\n                a++;\n            }\n        }\n        c = a + b;\n    }\n\n    function testDoWhile() public {\n        i = 10;\n        do {\n            i--;\n            a = 10;\n        } while(i > 0);\n    }\n}','0:0:0:0:0:0:0:1','2019-11-20 21:22:54');
/*!40000 ALTER TABLE `contracts` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `issues`
--

DROP TABLE IF EXISTS `issues`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `issues` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `contractid` int(11) NOT NULL,
  `vulnerabilityid` int(11) NOT NULL,
  `line` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `issues`
--

LOCK TABLES `issues` WRITE;
/*!40000 ALTER TABLE `issues` DISABLE KEYS */;
INSERT INTO `issues` VALUES (561,28,1,201),(562,28,1,213),(563,28,1,201),(564,28,1,213),(565,28,5,15),(566,28,5,16),(567,28,5,17),(568,28,5,34),(569,28,5,35),(570,28,6,56),(571,28,6,58),(572,28,6,64),(573,28,6,212),(574,28,6,56),(575,28,6,58),(576,28,6,64),(577,28,6,212),(578,28,7,36),(579,28,7,57),(580,28,7,58),(581,28,7,63),(582,28,7,64),(583,28,7,200),(584,28,7,207),(585,28,7,214),(586,28,7,36),(587,28,7,57),(588,28,7,58),(589,28,7,63),(590,28,7,64),(591,28,7,200),(592,28,7,207),(593,28,7,214),(594,28,8,97),(595,28,8,124),(596,28,8,185),(597,28,8,97),(598,28,8,124),(599,28,8,185),(600,29,1,201),(601,29,1,213),(602,29,5,15),(603,29,5,16),(604,29,5,34),(605,29,5,35),(606,29,6,56),(607,29,6,58),(608,29,6,64),(609,29,6,212),(610,29,7,36),(611,29,7,57),(612,29,7,58),(613,29,7,63),(614,29,7,64),(615,29,7,200),(616,29,7,207),(617,29,7,214),(618,29,8,97),(619,29,8,124),(620,30,1,201),(621,30,1,213),(622,30,1,201),(623,30,1,213),(624,30,1,201),(625,30,1,213),(626,30,1,201),(627,30,1,213),(628,30,5,15),(629,30,5,16),(630,30,5,17),(631,30,5,34),(632,30,5,35),(633,30,6,56),(634,30,6,58),(635,30,6,64),(636,30,6,212),(637,30,6,56),(638,30,6,58),(639,30,6,64),(640,30,6,212),(641,30,6,56),(642,30,6,58),(643,30,6,64),(644,30,6,212),(645,30,6,56),(646,30,6,58),(647,30,6,64),(648,30,6,212),(649,30,7,36),(650,30,7,57),(651,30,7,58),(652,30,7,63),(653,30,7,64),(654,30,7,200),(655,30,7,207),(656,30,7,214),(657,30,7,36),(658,30,7,57),(659,30,7,58),(660,30,7,63),(661,30,7,64),(662,30,7,200),(663,30,7,207),(664,30,7,214),(665,30,7,36),(666,30,7,57),(667,30,7,58),(668,30,7,63),(669,30,7,64),(670,30,7,200),(671,30,7,207),(672,30,7,214),(673,30,7,36),(674,30,7,57),(675,30,7,58),(676,30,7,63),(677,30,7,64),(678,30,7,200),(679,30,7,207),(680,30,7,214),(681,30,8,97),(682,30,8,124),(683,30,8,185),(684,30,8,97),(685,30,8,124),(686,30,8,185),(687,30,8,97),(688,30,8,124),(689,30,8,185),(690,30,8,97),(691,30,8,124),(692,30,8,185),(693,31,1,201),(694,31,1,213),(695,31,5,15),(696,31,5,16),(697,31,5,34),(698,31,5,35),(699,31,6,56),(700,31,6,58),(701,31,6,64),(702,31,6,212),(703,31,7,36),(704,31,7,57),(705,31,7,58),(706,31,7,63),(707,31,7,64),(708,31,7,200),(709,31,7,207),(710,31,7,214),(711,31,8,97),(712,31,8,124),(713,32,1,201),(714,32,1,213),(715,32,5,15),(716,32,5,16),(717,32,5,34),(718,32,5,35),(719,32,6,56),(720,32,6,58),(721,32,6,64),(722,32,6,212),(723,32,7,36),(724,32,7,57),(725,32,7,58),(726,32,7,63),(727,32,7,64),(728,32,7,200),(729,32,7,207),(730,32,7,214),(731,32,8,97),(732,32,8,124),(733,33,1,201),(734,33,1,213),(735,33,1,201),(736,33,1,213),(737,33,5,15),(738,33,5,16),(739,33,5,17),(740,33,5,34),(741,33,5,35),(742,33,6,56),(743,33,6,58),(744,33,6,64),(745,33,6,212),(746,33,6,56),(747,33,6,58),(748,33,6,64),(749,33,6,212),(750,33,7,36),(751,33,7,57),(752,33,7,58),(753,33,7,63),(754,33,7,64),(755,33,7,200),(756,33,7,207),(757,33,7,214),(758,33,7,36),(759,33,7,57),(760,33,7,58),(761,33,7,63),(762,33,7,64),(763,33,7,200),(764,33,7,207),(765,33,7,214),(766,33,8,97),(767,33,8,124),(768,33,8,185),(769,33,8,97),(770,33,8,124),(771,33,8,185),(772,34,1,201),(773,34,1,213),(774,34,1,201),(775,34,1,213),(776,34,1,201),(777,34,1,213),(778,34,5,15),(779,34,5,16),(780,34,5,17),(781,34,5,34),(782,34,5,35),(783,34,6,56),(784,34,6,58),(785,34,6,64),(786,34,6,212),(787,34,6,56),(788,34,6,58),(789,34,6,64),(790,34,6,212),(791,34,6,56),(792,34,6,58),(793,34,6,64),(794,34,6,212),(795,34,7,36),(796,34,7,57),(797,34,7,58),(798,34,7,63),(799,34,7,64),(800,34,7,200),(801,34,7,207),(802,34,7,214),(803,34,7,36),(804,34,7,57),(805,34,7,58),(806,34,7,63),(807,34,7,64),(808,34,7,200),(809,34,7,207),(810,34,7,214),(811,34,7,36),(812,34,7,57),(813,34,7,58),(814,34,7,63),(815,34,7,64),(816,34,7,200),(817,34,7,207),(818,34,7,214),(819,34,8,97),(820,34,8,124),(821,34,8,185),(822,34,8,97),(823,34,8,124),(824,34,8,185),(825,34,8,97),(826,34,8,124),(827,34,8,185),(828,35,1,201),(829,35,1,213),(830,35,1,201),(831,35,1,213),(832,35,1,201),(833,35,1,213),(834,35,1,201),(835,35,1,213),(836,35,5,15),(837,35,5,16),(838,35,5,17),(839,35,5,34),(840,35,5,35),(841,35,6,56),(842,35,6,58),(843,35,6,64),(844,35,6,212),(845,35,6,56),(846,35,6,58),(847,35,6,64),(848,35,6,212),(849,35,6,56),(850,35,6,58),(851,35,6,64),(852,35,6,212),(853,35,6,56),(854,35,6,58),(855,35,6,64),(856,35,6,212),(857,35,7,36),(858,35,7,57),(859,35,7,58),(860,35,7,63),(861,35,7,64),(862,35,7,200),(863,35,7,207),(864,35,7,214),(865,35,7,36),(866,35,7,57),(867,35,7,58),(868,35,7,63),(869,35,7,64),(870,35,7,200),(871,35,7,207),(872,35,7,214),(873,35,7,36),(874,35,7,57),(875,35,7,58),(876,35,7,63),(877,35,7,64),(878,35,7,200),(879,35,7,207),(880,35,7,214),(881,35,7,36),(882,35,7,57),(883,35,7,58),(884,35,7,63),(885,35,7,64),(886,35,7,200),(887,35,7,207),(888,35,7,214),(889,35,8,97),(890,35,8,124),(891,35,8,185),(892,35,8,97),(893,35,8,124),(894,35,8,185),(895,35,8,97),(896,35,8,124),(897,35,8,185),(898,35,8,97),(899,35,8,124),(900,35,8,185),(901,36,1,201),(902,36,1,213),(903,36,1,201),(904,36,1,213),(905,36,1,201),(906,36,1,213),(907,36,1,201),(908,36,1,213),(909,36,1,201),(910,36,1,213),(911,36,5,15),(912,36,5,16),(913,36,5,17),(914,36,5,34),(915,36,5,35),(916,36,6,56),(917,36,6,58),(918,36,6,64),(919,36,6,212),(920,36,6,56),(921,36,6,58),(922,36,6,64),(923,36,6,212),(924,36,6,56),(925,36,6,58),(926,36,6,64),(927,36,6,212),(928,36,6,56),(929,36,6,58),(930,36,6,64),(931,36,6,212),(932,36,6,56),(933,36,6,58),(934,36,6,64),(935,36,6,212),(936,36,7,36),(937,36,7,57),(938,36,7,58),(939,36,7,63),(940,36,7,64),(941,36,7,200),(942,36,7,207),(943,36,7,214),(944,36,7,36),(945,36,7,57),(946,36,7,58),(947,36,7,63),(948,36,7,64),(949,36,7,200),(950,36,7,207),(951,36,7,214),(952,36,7,36),(953,36,7,57),(954,36,7,58),(955,36,7,63),(956,36,7,64),(957,36,7,200),(958,36,7,207),(959,36,7,214),(960,36,7,36),(961,36,7,57),(962,36,7,58),(963,36,7,63),(964,36,7,64),(965,36,7,200),(966,36,7,207),(967,36,7,214),(968,36,7,36),(969,36,7,57),(970,36,7,58),(971,36,7,63),(972,36,7,64),(973,36,7,200),(974,36,7,207),(975,36,7,214),(976,36,8,97),(977,36,8,124),(978,36,8,185),(979,36,8,97),(980,36,8,124),(981,36,8,185),(982,36,8,97),(983,36,8,124),(984,36,8,185),(985,36,8,97),(986,36,8,124),(987,36,8,185),(988,36,8,97),(989,36,8,124),(990,36,8,185),(991,37,1,201),(992,37,1,213),(993,37,5,15),(994,37,5,16),(995,37,5,34),(996,37,5,35),(997,37,6,56),(998,37,6,58),(999,37,6,64),(1000,37,6,212),(1001,37,7,36),(1002,37,7,57),(1003,37,7,58),(1004,37,7,63),(1005,37,7,64),(1006,37,7,200),(1007,37,7,207),(1008,37,7,214),(1009,37,8,97),(1010,37,8,124),(1011,38,1,201),(1012,38,1,213),(1013,38,1,201),(1014,38,1,213),(1015,38,5,15),(1016,38,5,16),(1017,38,5,17),(1018,38,5,34),(1019,38,5,35),(1020,38,6,56),(1021,38,6,58),(1022,38,6,64),(1023,38,6,212),(1024,38,6,56),(1025,38,6,58),(1026,38,6,64),(1027,38,6,212),(1028,38,7,36),(1029,38,7,57),(1030,38,7,58),(1031,38,7,63),(1032,38,7,64),(1033,38,7,200),(1034,38,7,207),(1035,38,7,214),(1036,38,7,36),(1037,38,7,57),(1038,38,7,58),(1039,38,7,63),(1040,38,7,64),(1041,38,7,200),(1042,38,7,207),(1043,38,7,214),(1044,38,8,97),(1045,38,8,124),(1046,38,8,185),(1047,38,8,97),(1048,38,8,124),(1049,38,8,185),(1050,39,1,201),(1051,39,1,213),(1052,39,1,201),(1053,39,1,213),(1054,39,1,201),(1055,39,1,213),(1056,39,5,15),(1057,39,5,16),(1058,39,5,17),(1059,39,5,34),(1060,39,5,35),(1061,39,6,56),(1062,39,6,58),(1063,39,6,64),(1064,39,6,212),(1065,39,6,56),(1066,39,6,58),(1067,39,6,64),(1068,39,6,212),(1069,39,6,56),(1070,39,6,58),(1071,39,6,64),(1072,39,6,212),(1073,39,7,36),(1074,39,7,57),(1075,39,7,58),(1076,39,7,63),(1077,39,7,64),(1078,39,7,200),(1079,39,7,207),(1080,39,7,214),(1081,39,7,36),(1082,39,7,57),(1083,39,7,58),(1084,39,7,63),(1085,39,7,64),(1086,39,7,200),(1087,39,7,207),(1088,39,7,214),(1089,39,7,36),(1090,39,7,57),(1091,39,7,58),(1092,39,7,63),(1093,39,7,64),(1094,39,7,200),(1095,39,7,207),(1096,39,7,214),(1097,39,8,97),(1098,39,8,124),(1099,39,8,185),(1100,39,8,97),(1101,39,8,124),(1102,39,8,185),(1103,39,8,97),(1104,39,8,124),(1105,39,8,185),(1106,40,1,201),(1107,40,1,213),(1108,40,5,15),(1109,40,5,16),(1110,40,5,34),(1111,40,5,35),(1112,40,6,56),(1113,40,6,58),(1114,40,6,64),(1115,40,6,212),(1116,40,7,36),(1117,40,7,57),(1118,40,7,58),(1119,40,7,63),(1120,40,7,64),(1121,40,7,200),(1122,40,7,207),(1123,40,7,214),(1124,40,8,97),(1125,40,8,124),(1126,41,1,201),(1127,41,1,213),(1128,41,1,201),(1129,41,1,213),(1130,41,5,15),(1131,41,5,16),(1132,41,5,17),(1133,41,5,34),(1134,41,5,35),(1135,41,6,56),(1136,41,6,58),(1137,41,6,64),(1138,41,6,212),(1139,41,6,56),(1140,41,6,58),(1141,41,6,64),(1142,41,6,212),(1143,41,7,36),(1144,41,7,57),(1145,41,7,58),(1146,41,7,63),(1147,41,7,64),(1148,41,7,200),(1149,41,7,207),(1150,41,7,214),(1151,41,7,36),(1152,41,7,57),(1153,41,7,58),(1154,41,7,63),(1155,41,7,64),(1156,41,7,200),(1157,41,7,207),(1158,41,7,214),(1159,41,8,97),(1160,41,8,124),(1161,41,8,185),(1162,41,8,97),(1163,41,8,124),(1164,41,8,185),(1165,42,1,201),(1166,42,1,213),(1167,42,5,15),(1168,42,5,16),(1169,42,5,34),(1170,42,5,35),(1171,42,6,56),(1172,42,6,58),(1173,42,6,64),(1174,42,6,212),(1175,42,7,36),(1176,42,7,57),(1177,42,7,58),(1178,42,7,63),(1179,42,7,64),(1180,42,7,200),(1181,42,7,207),(1182,42,7,214),(1183,42,8,97),(1184,42,8,124),(1185,43,1,201),(1186,43,1,213),(1187,43,5,15),(1188,43,5,16),(1189,43,5,34),(1190,43,5,35),(1191,43,6,56),(1192,43,6,58),(1193,43,6,64),(1194,43,6,212),(1195,43,7,36),(1196,43,7,57),(1197,43,7,58),(1198,43,7,63),(1199,43,7,64),(1200,43,7,200),(1201,43,7,207),(1202,43,7,214),(1203,43,8,97),(1204,43,8,124),(1205,44,1,201),(1206,44,1,213),(1207,44,5,15),(1208,44,5,16),(1209,44,5,34),(1210,44,5,35),(1211,44,6,56),(1212,44,6,58),(1213,44,6,64),(1214,44,6,212),(1215,44,7,36),(1216,44,7,57),(1217,44,7,58),(1218,44,7,63),(1219,44,7,64),(1220,44,7,200),(1221,44,7,207),(1222,44,7,214),(1223,44,8,97),(1224,44,8,124),(1225,45,1,-1),(1226,45,1,-1),(1227,45,5,15),(1228,45,5,15),(1229,45,5,26),(1230,45,5,26),(1231,45,6,35),(1232,45,6,36),(1233,45,6,40),(1234,45,6,-1),(1235,45,7,27),(1236,45,7,36),(1237,45,7,36),(1238,45,7,39),(1239,45,7,40),(1240,45,7,-1),(1241,45,7,-1),(1242,45,7,-1),(1243,45,8,54),(1244,45,8,62),(1245,46,1,201),(1246,46,1,213),(1247,46,5,15),(1248,46,5,16),(1249,46,5,34),(1250,46,5,35),(1251,46,6,56),(1252,46,6,58),(1253,46,6,64),(1254,46,6,212),(1255,46,7,36),(1256,46,7,57),(1257,46,7,58),(1258,46,7,63),(1259,46,7,64),(1260,46,7,200),(1261,46,7,207),(1262,46,7,214),(1263,46,8,97),(1264,46,8,124),(1265,47,1,192),(1266,47,1,206),(1267,47,5,14),(1268,47,5,15),(1269,47,5,32),(1270,47,5,33),(1271,47,6,55),(1272,47,6,56),(1273,47,6,62),(1274,47,6,206),(1275,47,7,34),(1276,47,7,55),(1277,47,7,56),(1278,47,7,61),(1279,47,7,62),(1280,47,7,191),(1281,47,7,199),(1282,47,7,208),(1283,47,8,89),(1284,47,8,113),(1285,48,1,-1),(1286,48,1,-1),(1287,48,5,-1),(1288,48,5,-1),(1289,48,5,-1),(1290,48,5,-1),(1291,48,6,-1),(1292,48,6,-1),(1293,48,6,-1),(1294,48,6,-1),(1295,48,7,-1),(1296,48,7,-1),(1297,48,7,-1),(1298,48,7,-1),(1299,48,7,-1),(1300,48,7,-1),(1301,48,7,-1),(1302,48,7,-1),(1303,48,8,-1),(1304,48,8,-1),(1305,49,1,-1),(1306,49,1,-1),(1307,49,5,-1),(1308,49,5,-1),(1309,49,5,-1),(1310,49,5,-1),(1311,49,6,-1),(1312,49,6,-1),(1313,49,6,-1),(1314,49,6,-1),(1315,49,7,-1),(1316,49,7,-1),(1317,49,7,-1),(1318,49,7,-1),(1319,49,7,-1),(1320,49,7,-1),(1321,49,7,-1),(1322,49,7,-1),(1323,49,8,-1),(1324,49,8,-1),(1325,50,1,-1),(1326,50,1,-1),(1327,50,5,-1),(1328,50,5,-1),(1329,50,5,-1),(1330,50,5,-1),(1331,50,6,-1),(1332,50,6,-1),(1333,50,6,-1),(1334,50,6,-1),(1335,50,7,-1),(1336,50,7,-1),(1337,50,7,-1),(1338,50,7,-1),(1339,50,7,-1),(1340,50,7,-1),(1341,50,7,-1),(1342,50,7,-1),(1343,50,8,-1),(1344,50,8,-1),(1345,51,1,-1),(1346,51,1,-1),(1347,51,1,-1),(1348,51,1,-1),(1349,51,5,-1),(1350,51,5,-1),(1351,51,5,-1),(1352,51,5,-1),(1353,51,5,-1),(1354,51,6,-1),(1355,51,6,-1),(1356,51,6,-1),(1357,51,6,-1),(1358,51,6,-1),(1359,51,6,-1),(1360,51,6,-1),(1361,51,6,-1),(1362,51,7,-1),(1363,51,7,-1),(1364,51,7,-1),(1365,51,7,-1),(1366,51,7,-1),(1367,51,7,-1),(1368,51,7,-1),(1369,51,7,-1),(1370,51,7,-1),(1371,51,7,-1),(1372,51,7,-1),(1373,51,7,-1),(1374,51,7,-1),(1375,51,7,-1),(1376,51,7,-1),(1377,51,7,-1),(1378,51,8,-1),(1379,51,8,-1),(1380,51,8,-1),(1381,51,8,-1),(1382,51,8,-1),(1383,51,8,-1),(1384,52,1,-1),(1385,52,1,-1),(1386,52,5,-1),(1387,52,5,-1),(1388,52,5,-1),(1389,52,5,-1),(1390,52,6,-1),(1391,52,6,-1),(1392,52,6,-1),(1393,52,6,-1),(1394,52,7,-1),(1395,52,7,-1),(1396,52,7,-1),(1397,52,7,-1),(1398,52,7,-1),(1399,52,7,-1),(1400,52,7,-1),(1401,52,7,-1),(1402,52,8,-1),(1403,52,8,-1),(1404,53,1,192),(1405,53,1,206),(1406,53,5,14),(1407,53,5,15),(1408,53,5,32),(1409,53,5,33),(1410,53,6,55),(1411,53,6,56),(1412,53,6,62),(1413,53,6,206),(1414,53,7,34),(1415,53,7,55),(1416,53,7,56),(1417,53,7,61),(1418,53,7,62),(1419,53,7,191),(1420,53,7,199),(1421,53,7,208),(1422,53,8,89),(1423,53,8,113),(1424,54,1,192),(1425,54,1,206),(1426,54,1,192),(1427,54,1,206),(1428,54,5,14),(1429,54,5,15),(1430,54,5,16),(1431,54,5,32),(1432,54,5,33),(1433,54,6,55),(1434,54,6,56),(1435,54,6,62),(1436,54,6,206),(1437,54,6,55),(1438,54,6,56),(1439,54,6,62),(1440,54,6,206),(1441,54,7,34),(1442,54,7,55),(1443,54,7,56),(1444,54,7,61),(1445,54,7,62),(1446,54,7,191),(1447,54,7,199),(1448,54,7,208),(1449,54,7,34),(1450,54,7,55),(1451,54,7,56),(1452,54,7,61),(1453,54,7,62),(1454,54,7,191),(1455,54,7,199),(1456,54,7,208),(1457,54,8,89),(1458,54,8,113),(1459,54,8,171),(1460,54,8,89),(1461,54,8,113),(1462,54,8,171),(1463,55,1,192),(1464,55,1,206),(1465,55,1,192),(1466,55,1,206),(1467,55,1,192),(1468,55,1,206),(1469,55,5,14),(1470,55,5,15),(1471,55,5,16),(1472,55,5,32),(1473,55,5,33),(1474,55,6,55),(1475,55,6,56),(1476,55,6,62),(1477,55,6,206),(1478,55,6,55),(1479,55,6,56),(1480,55,6,62),(1481,55,6,206),(1482,55,6,55),(1483,55,6,56),(1484,55,6,62),(1485,55,6,206),(1486,55,7,34),(1487,55,7,55),(1488,55,7,56),(1489,55,7,61),(1490,55,7,62),(1491,55,7,191),(1492,55,7,199),(1493,55,7,208),(1494,55,7,34),(1495,55,7,55),(1496,55,7,56),(1497,55,7,61),(1498,55,7,62),(1499,55,7,191),(1500,55,7,199),(1501,55,7,208),(1502,55,7,34),(1503,55,7,55),(1504,55,7,56),(1505,55,7,61),(1506,55,7,62),(1507,55,7,191),(1508,55,7,199),(1509,55,7,208),(1510,55,8,89),(1511,55,8,113),(1512,55,8,171),(1513,55,8,89),(1514,55,8,113),(1515,55,8,171),(1516,55,8,89),(1517,55,8,113),(1518,55,8,171),(1519,56,1,13),(1520,56,1,24),(1521,56,6,23),(1522,56,7,13),(1523,56,7,19),(1524,56,7,25),(1525,57,1,13),(1526,57,1,24),(1527,57,6,23),(1528,57,7,13),(1529,57,7,19),(1530,57,7,25),(1531,58,1,13),(1532,58,1,24),(1533,58,6,23),(1534,58,7,13),(1535,58,7,19),(1536,58,7,25),(1537,59,1,13),(1538,59,1,24),(1539,59,6,23),(1540,59,7,13),(1541,59,7,19),(1542,59,7,25),(1543,60,1,13),(1544,60,1,24),(1545,60,6,23),(1546,60,7,13),(1547,60,7,19),(1548,60,7,25),(1549,61,1,13),(1550,61,1,24),(1551,61,6,23),(1552,61,7,13),(1553,61,7,19),(1554,61,7,25),(1555,62,1,13),(1556,62,1,24),(1557,62,6,23),(1558,62,7,13),(1559,62,7,19),(1560,62,7,25),(1561,63,1,13),(1562,63,1,24),(1563,63,1,-1),(1564,63,1,-1),(1565,63,5,13),(1566,63,5,14),(1567,63,5,25),(1568,63,5,26),(1569,63,6,23),(1570,63,6,-1),(1571,63,6,-1),(1572,63,6,-1),(1573,63,6,-1),(1574,63,7,13),(1575,63,7,19),(1576,63,7,25),(1577,63,7,26),(1578,63,7,-1),(1579,63,7,-1),(1580,63,7,-1),(1581,63,7,-1),(1582,63,7,-1),(1583,63,7,-1),(1584,63,7,-1),(1585,63,8,-1),(1586,63,8,-1),(1587,64,1,192),(1588,64,1,206),(1589,64,5,14),(1590,64,5,15),(1591,64,5,32),(1592,64,5,33),(1593,64,6,55),(1594,64,6,56),(1595,64,6,62),(1596,64,6,206),(1597,64,7,34),(1598,64,7,55),(1599,64,7,56),(1600,64,7,61),(1601,64,7,62),(1602,64,7,191),(1603,64,7,199),(1604,64,7,208),(1605,64,8,89),(1606,64,8,113),(1607,65,1,192),(1608,65,1,206),(1609,65,1,192),(1610,65,1,206),(1611,65,5,14),(1612,65,5,15),(1613,65,5,16),(1614,65,5,32),(1615,65,5,33),(1616,65,6,55),(1617,65,6,56),(1618,65,6,62),(1619,65,6,206),(1620,65,6,55),(1621,65,6,56),(1622,65,6,62),(1623,65,6,206),(1624,65,7,34),(1625,65,7,55),(1626,65,7,56),(1627,65,7,61),(1628,65,7,62),(1629,65,7,191),(1630,65,7,199),(1631,65,7,208),(1632,65,7,34),(1633,65,7,55),(1634,65,7,56),(1635,65,7,61),(1636,65,7,62),(1637,65,7,191),(1638,65,7,199),(1639,65,7,208),(1640,65,8,89),(1641,65,8,113),(1642,65,8,171),(1643,65,8,89),(1644,65,8,113),(1645,65,8,171),(1646,66,1,192),(1647,66,1,206),(1648,66,1,192),(1649,66,1,206),(1650,66,1,192),(1651,66,1,206),(1652,66,5,14),(1653,66,5,15),(1654,66,5,16),(1655,66,5,32),(1656,66,5,33),(1657,66,6,55),(1658,66,6,56),(1659,66,6,62),(1660,66,6,206),(1661,66,6,55),(1662,66,6,56),(1663,66,6,62),(1664,66,6,206),(1665,66,6,55),(1666,66,6,56),(1667,66,6,62),(1668,66,6,206),(1669,66,7,34),(1670,66,7,55),(1671,66,7,56),(1672,66,7,61),(1673,66,7,62),(1674,66,7,191),(1675,66,7,199),(1676,66,7,208),(1677,66,7,34),(1678,66,7,55),(1679,66,7,56),(1680,66,7,61),(1681,66,7,62),(1682,66,7,191),(1683,66,7,199),(1684,66,7,208),(1685,66,7,34),(1686,66,7,55),(1687,66,7,56),(1688,66,7,61),(1689,66,7,62),(1690,66,7,191),(1691,66,7,199),(1692,66,7,208),(1693,66,8,89),(1694,66,8,113),(1695,66,8,171),(1696,66,8,89),(1697,66,8,113),(1698,66,8,171),(1699,66,8,89),(1700,66,8,113),(1701,66,8,171),(1702,67,1,192),(1703,67,1,206),(1704,67,5,14),(1705,67,5,15),(1706,67,5,32),(1707,67,5,33),(1708,67,6,55),(1709,67,6,56),(1710,67,6,62),(1711,67,6,206),(1712,67,7,34),(1713,67,7,55),(1714,67,7,56),(1715,67,7,61),(1716,67,7,62),(1717,67,7,191),(1718,67,7,199),(1719,67,7,208),(1720,67,8,89),(1721,67,8,113),(1722,68,1,192),(1723,68,1,206),(1724,68,1,192),(1725,68,1,206),(1726,68,5,14),(1727,68,5,15),(1728,68,5,16),(1729,68,5,32),(1730,68,5,33),(1731,68,6,55),(1732,68,6,56),(1733,68,6,62),(1734,68,6,206),(1735,68,6,55),(1736,68,6,56),(1737,68,6,62),(1738,68,6,206),(1739,68,7,34),(1740,68,7,55),(1741,68,7,56),(1742,68,7,61),(1743,68,7,62),(1744,68,7,191),(1745,68,7,199),(1746,68,7,208),(1747,68,7,34),(1748,68,7,55),(1749,68,7,56),(1750,68,7,61),(1751,68,7,62),(1752,68,7,191),(1753,68,7,199),(1754,68,7,208),(1755,68,8,89),(1756,68,8,113),(1757,68,8,171),(1758,68,8,89),(1759,68,8,113),(1760,68,8,171),(1761,69,1,192),(1762,69,1,206),(1763,69,1,192),(1764,69,1,206),(1765,69,1,192),(1766,69,1,206),(1767,69,5,14),(1768,69,5,15),(1769,69,5,16),(1770,69,5,32),(1771,69,5,33),(1772,69,6,55),(1773,69,6,56),(1774,69,6,62),(1775,69,6,206),(1776,69,6,55),(1777,69,6,56),(1778,69,6,62),(1779,69,6,206),(1780,69,6,55),(1781,69,6,56),(1782,69,6,62),(1783,69,6,206),(1784,69,7,34),(1785,69,7,55),(1786,69,7,56),(1787,69,7,61),(1788,69,7,62),(1789,69,7,191),(1790,69,7,199),(1791,69,7,208),(1792,69,7,34),(1793,69,7,55),(1794,69,7,56),(1795,69,7,61),(1796,69,7,62),(1797,69,7,191),(1798,69,7,199),(1799,69,7,208),(1800,69,7,34),(1801,69,7,55),(1802,69,7,56),(1803,69,7,61),(1804,69,7,62),(1805,69,7,191),(1806,69,7,199),(1807,69,7,208),(1808,69,8,89),(1809,69,8,113),(1810,69,8,171),(1811,69,8,89),(1812,69,8,113),(1813,69,8,171),(1814,69,8,89),(1815,69,8,113),(1816,69,8,171),(1817,70,1,192),(1818,70,1,206),(1819,70,1,192),(1820,70,1,206),(1821,70,1,192),(1822,70,1,206),(1823,70,1,192),(1824,70,1,206),(1825,70,5,14),(1826,70,5,15),(1827,70,5,16),(1828,70,5,32),(1829,70,5,33),(1830,70,6,55),(1831,70,6,56),(1832,70,6,62),(1833,70,6,206),(1834,70,6,55),(1835,70,6,56),(1836,70,6,62),(1837,70,6,206),(1838,70,6,55),(1839,70,6,56),(1840,70,6,62),(1841,70,6,206),(1842,70,6,55),(1843,70,6,56),(1844,70,6,62),(1845,70,6,206),(1846,70,7,34),(1847,70,7,55),(1848,70,7,56),(1849,70,7,61),(1850,70,7,62),(1851,70,7,191),(1852,70,7,199),(1853,70,7,208),(1854,70,7,34),(1855,70,7,55),(1856,70,7,56),(1857,70,7,61),(1858,70,7,62),(1859,70,7,191),(1860,70,7,199),(1861,70,7,208),(1862,70,7,34),(1863,70,7,55),(1864,70,7,56),(1865,70,7,61),(1866,70,7,62),(1867,70,7,191),(1868,70,7,199),(1869,70,7,208),(1870,70,7,34),(1871,70,7,55),(1872,70,7,56),(1873,70,7,61),(1874,70,7,62),(1875,70,7,191),(1876,70,7,199),(1877,70,7,208),(1878,70,8,89),(1879,70,8,113),(1880,70,8,171),(1881,70,8,89),(1882,70,8,113),(1883,70,8,171),(1884,70,8,89),(1885,70,8,113),(1886,70,8,171),(1887,70,8,89),(1888,70,8,113),(1889,70,8,171),(1890,71,1,192),(1891,71,1,206),(1892,71,1,192),(1893,71,1,206),(1894,71,1,192),(1895,71,1,206),(1896,71,1,192),(1897,71,1,206),(1898,71,1,192),(1899,71,1,206),(1900,71,5,14),(1901,71,5,15),(1902,71,5,16),(1903,71,5,32),(1904,71,5,33),(1905,71,6,55),(1906,71,6,56),(1907,71,6,62),(1908,71,6,206),(1909,71,6,55),(1910,71,6,56),(1911,71,6,62),(1912,71,6,206),(1913,71,6,55),(1914,71,6,56),(1915,71,6,62),(1916,71,6,206),(1917,71,6,55),(1918,71,6,56),(1919,71,6,62),(1920,71,6,206),(1921,71,6,55),(1922,71,6,56),(1923,71,6,62),(1924,71,6,206),(1925,71,7,34),(1926,71,7,55),(1927,71,7,56),(1928,71,7,61),(1929,71,7,62),(1930,71,7,191),(1931,71,7,199),(1932,71,7,208),(1933,71,7,34),(1934,71,7,55),(1935,71,7,56),(1936,71,7,61),(1937,71,7,62),(1938,71,7,191),(1939,71,7,199),(1940,71,7,208),(1941,71,7,34),(1942,71,7,55),(1943,71,7,56),(1944,71,7,61),(1945,71,7,62),(1946,71,7,191),(1947,71,7,199),(1948,71,7,208),(1949,71,7,34),(1950,71,7,55),(1951,71,7,56),(1952,71,7,61),(1953,71,7,62),(1954,71,7,191),(1955,71,7,199),(1956,71,7,208),(1957,71,7,34),(1958,71,7,55),(1959,71,7,56),(1960,71,7,61),(1961,71,7,62),(1962,71,7,191),(1963,71,7,199),(1964,71,7,208),(1965,71,8,89),(1966,71,8,113),(1967,71,8,171),(1968,71,8,89),(1969,71,8,113),(1970,71,8,171),(1971,71,8,89),(1972,71,8,113),(1973,71,8,171),(1974,71,8,89),(1975,71,8,113),(1976,71,8,171),(1977,71,8,89),(1978,71,8,113),(1979,71,8,171),(1980,72,1,192),(1981,72,1,206),(1982,72,5,14),(1983,72,5,15),(1984,72,5,32),(1985,72,5,33),(1986,72,6,55),(1987,72,6,56),(1988,72,6,62),(1989,72,6,206),(1990,72,7,34),(1991,72,7,55),(1992,72,7,56),(1993,72,7,61),(1994,72,7,62),(1995,72,7,191),(1996,72,7,199),(1997,72,7,208),(1998,72,8,89),(1999,72,8,113),(2000,73,1,192),(2001,73,1,206),(2002,73,1,192),(2003,73,1,206),(2004,73,5,14),(2005,73,5,15),(2006,73,5,16),(2007,73,5,32),(2008,73,5,33),(2009,73,6,55),(2010,73,6,56),(2011,73,6,62),(2012,73,6,206),(2013,73,6,55),(2014,73,6,56),(2015,73,6,62),(2016,73,6,206),(2017,73,7,34),(2018,73,7,55),(2019,73,7,56),(2020,73,7,61),(2021,73,7,62),(2022,73,7,191),(2023,73,7,199),(2024,73,7,208),(2025,73,7,34),(2026,73,7,55),(2027,73,7,56),(2028,73,7,61),(2029,73,7,62),(2030,73,7,191),(2031,73,7,199),(2032,73,7,208),(2033,73,8,89),(2034,73,8,113),(2035,73,8,171),(2036,73,8,89),(2037,73,8,113),(2038,73,8,171),(2039,74,1,192),(2040,74,1,206),(2041,74,5,14),(2042,74,5,15),(2043,74,5,32),(2044,74,5,33),(2045,74,6,55),(2046,74,6,56),(2047,74,6,62),(2048,74,6,206),(2049,74,7,34),(2050,74,7,55),(2051,74,7,56),(2052,74,7,61),(2053,74,7,62),(2054,74,7,191),(2055,74,7,199),(2056,74,7,208),(2057,74,8,89),(2058,74,8,113),(2059,75,1,192),(2060,75,1,206),(2061,75,1,192),(2062,75,1,206),(2063,75,5,14),(2064,75,5,15),(2065,75,5,16),(2066,75,5,32),(2067,75,5,33),(2068,75,6,55),(2069,75,6,56),(2070,75,6,62),(2071,75,6,206),(2072,75,6,55),(2073,75,6,56),(2074,75,6,62),(2075,75,6,206),(2076,75,7,34),(2077,75,7,55),(2078,75,7,56),(2079,75,7,61),(2080,75,7,62),(2081,75,7,191),(2082,75,7,199),(2083,75,7,208),(2084,75,7,34),(2085,75,7,55),(2086,75,7,56),(2087,75,7,61),(2088,75,7,62),(2089,75,7,191),(2090,75,7,199),(2091,75,7,208),(2092,75,8,89),(2093,75,8,113),(2094,75,8,171),(2095,75,8,89),(2096,75,8,113),(2097,75,8,171),(2098,76,1,192),(2099,76,1,206),(2100,76,1,192),(2101,76,1,206),(2102,76,1,192),(2103,76,1,206),(2104,76,5,14),(2105,76,5,15),(2106,76,5,16),(2107,76,5,32),(2108,76,5,33),(2109,76,6,55),(2110,76,6,56),(2111,76,6,62),(2112,76,6,206),(2113,76,6,55),(2114,76,6,56),(2115,76,6,62),(2116,76,6,206),(2117,76,6,55),(2118,76,6,56),(2119,76,6,62),(2120,76,6,206),(2121,76,7,34),(2122,76,7,55),(2123,76,7,56),(2124,76,7,61),(2125,76,7,62),(2126,76,7,191),(2127,76,7,199),(2128,76,7,208),(2129,76,7,34),(2130,76,7,55),(2131,76,7,56),(2132,76,7,61),(2133,76,7,62),(2134,76,7,191),(2135,76,7,199),(2136,76,7,208),(2137,76,7,34),(2138,76,7,55),(2139,76,7,56),(2140,76,7,61),(2141,76,7,62),(2142,76,7,191),(2143,76,7,199),(2144,76,7,208),(2145,76,8,89),(2146,76,8,113),(2147,76,8,171),(2148,76,8,89),(2149,76,8,113),(2150,76,8,171),(2151,76,8,89),(2152,76,8,113),(2153,76,8,171),(2154,77,1,13),(2155,77,1,24),(2156,77,6,23),(2157,77,7,13),(2158,77,7,19),(2159,77,7,25),(2160,78,1,192),(2161,78,1,206),(2162,78,5,14),(2163,78,5,15),(2164,78,5,32),(2165,78,5,33),(2166,78,6,55),(2167,78,6,56),(2168,78,6,62),(2169,78,6,206),(2170,78,7,34),(2171,78,7,55),(2172,78,7,56),(2173,78,7,61),(2174,78,7,62),(2175,78,7,191),(2176,78,7,199),(2177,78,7,208),(2178,78,8,89),(2179,78,8,113),(2180,79,1,192),(2181,79,1,206),(2182,79,5,14),(2183,79,5,15),(2184,79,5,32),(2185,79,5,33),(2186,79,6,55),(2187,79,6,56),(2188,79,6,62),(2189,79,6,206),(2190,79,7,34),(2191,79,7,55),(2192,79,7,56),(2193,79,7,61),(2194,79,7,62),(2195,79,7,191),(2196,79,7,199),(2197,79,7,208),(2198,79,8,89),(2199,79,8,113),(2200,80,1,192),(2201,80,1,206),(2202,80,5,14),(2203,80,5,15),(2204,80,5,32),(2205,80,5,33),(2206,80,6,55),(2207,80,6,56),(2208,80,6,62),(2209,80,6,206),(2210,80,7,34),(2211,80,7,55),(2212,80,7,56),(2213,80,7,61),(2214,80,7,62),(2215,80,7,191),(2216,80,7,199),(2217,80,7,208),(2218,80,8,89),(2219,80,8,113),(2220,81,1,192),(2221,81,1,206),(2222,81,5,14),(2223,81,5,15),(2224,81,5,32),(2225,81,5,33),(2226,81,6,55),(2227,81,6,56),(2228,81,6,62),(2229,81,6,206),(2230,81,7,34),(2231,81,7,55),(2232,81,7,56),(2233,81,7,61),(2234,81,7,62),(2235,81,7,191),(2236,81,7,199),(2237,81,7,208),(2238,81,8,89),(2239,81,8,113),(2240,82,1,192),(2241,82,1,206),(2242,82,5,14),(2243,82,5,15),(2244,82,5,32),(2245,82,5,33),(2246,82,6,55),(2247,82,6,56),(2248,82,6,62),(2249,82,6,206),(2250,82,7,34),(2251,82,7,55),(2252,82,7,56),(2253,82,7,61),(2254,82,7,62),(2255,82,7,191),(2256,82,7,199),(2257,82,7,208),(2258,82,8,89),(2259,82,8,113),(2260,83,1,192),(2261,83,1,206),(2262,83,5,14),(2263,83,5,15),(2264,83,5,32),(2265,83,5,33),(2266,83,6,55),(2267,83,6,56),(2268,83,6,62),(2269,83,6,206),(2270,83,7,34),(2271,83,7,55),(2272,83,7,56),(2273,83,7,61),(2274,83,7,62),(2275,83,7,191),(2276,83,7,199),(2277,83,7,208),(2278,83,8,89),(2279,83,8,113),(2280,84,1,192),(2281,84,1,206),(2282,84,5,14),(2283,84,5,15),(2284,84,5,32),(2285,84,5,33),(2286,84,6,55),(2287,84,6,56),(2288,84,6,62),(2289,84,6,206),(2290,84,7,34),(2291,84,7,55),(2292,84,7,56),(2293,84,7,61),(2294,84,7,62),(2295,84,7,191),(2296,84,7,199),(2297,84,7,208),(2298,84,8,89),(2299,84,8,113),(2300,85,1,192),(2301,85,1,206),(2302,85,5,14),(2303,85,5,15),(2304,85,5,32),(2305,85,5,33),(2306,85,6,55),(2307,85,6,56),(2308,85,6,62),(2309,85,6,206),(2310,85,7,34),(2311,85,7,55),(2312,85,7,56),(2313,85,7,61),(2314,85,7,62),(2315,85,7,191),(2316,85,7,199),(2317,85,7,208),(2318,85,8,89),(2319,85,8,113),(2320,86,1,192),(2321,86,1,206),(2322,86,5,14),(2323,86,5,15),(2324,86,5,32),(2325,86,5,33),(2326,86,6,55),(2327,86,6,56),(2328,86,6,62),(2329,86,6,206),(2330,86,7,34),(2331,86,7,55),(2332,86,7,56),(2333,86,7,61),(2334,86,7,62),(2335,86,7,191),(2336,86,7,199),(2337,86,7,208),(2338,86,8,89),(2339,86,8,113),(2340,87,1,192),(2341,87,1,206),(2342,87,5,14),(2343,87,5,15),(2344,87,5,32),(2345,87,5,33),(2346,87,6,55),(2347,87,6,56),(2348,87,6,62),(2349,87,6,206),(2350,87,7,34),(2351,87,7,55),(2352,87,7,56),(2353,87,7,61),(2354,87,7,62),(2355,87,7,191),(2356,87,7,199),(2357,87,7,208),(2358,87,8,89),(2359,87,8,113),(2360,88,1,192),(2361,88,1,206),(2362,88,5,14),(2363,88,5,15),(2364,88,5,32),(2365,88,5,33),(2366,88,6,55),(2367,88,6,56),(2368,88,6,62),(2369,88,6,206),(2370,88,7,34),(2371,88,7,55),(2372,88,7,56),(2373,88,7,61),(2374,88,7,62),(2375,88,7,191),(2376,88,7,199),(2377,88,7,208),(2378,88,8,89),(2379,88,8,113),(2380,89,1,192),(2381,89,1,206),(2382,89,5,14),(2383,89,5,15),(2384,89,5,32),(2385,89,5,33),(2386,89,6,55),(2387,89,6,56),(2388,89,6,62),(2389,89,6,206),(2390,89,7,34),(2391,89,7,55),(2392,89,7,56),(2393,89,7,61),(2394,89,7,62),(2395,89,7,191),(2396,89,7,199),(2397,89,7,208),(2398,89,8,89),(2399,89,8,113),(2400,90,1,192),(2401,90,1,206),(2402,90,5,14),(2403,90,5,15),(2404,90,5,32),(2405,90,5,33),(2406,90,6,55),(2407,90,6,56),(2408,90,6,62),(2409,90,6,206),(2410,90,7,34),(2411,90,7,55),(2412,90,7,56),(2413,90,7,61),(2414,90,7,62),(2415,90,7,191),(2416,90,7,199),(2417,90,7,208),(2418,90,8,89),(2419,90,8,113),(2420,91,1,192),(2421,91,1,206),(2422,91,5,14),(2423,91,5,15),(2424,91,5,32),(2425,91,5,33),(2426,91,6,55),(2427,91,6,56),(2428,91,6,62),(2429,91,6,206),(2430,91,7,34),(2431,91,7,55),(2432,91,7,56),(2433,91,7,61),(2434,91,7,62),(2435,91,7,191),(2436,91,7,199),(2437,91,7,208),(2438,91,8,89),(2439,91,8,113),(2440,92,1,192),(2441,92,1,206),(2442,92,1,192),(2443,92,1,206),(2444,92,5,14),(2445,92,5,15),(2446,92,5,16),(2447,92,5,32),(2448,92,5,33),(2449,92,6,55),(2450,92,6,56),(2451,92,6,62),(2452,92,6,206),(2453,92,6,55),(2454,92,6,56),(2455,92,6,62),(2456,92,6,206),(2457,92,7,34),(2458,92,7,55),(2459,92,7,56),(2460,92,7,61),(2461,92,7,62),(2462,92,7,191),(2463,92,7,199),(2464,92,7,208),(2465,92,7,34),(2466,92,7,55),(2467,92,7,56),(2468,92,7,61),(2469,92,7,62),(2470,92,7,191),(2471,92,7,199),(2472,92,7,208),(2473,92,8,89),(2474,92,8,113),(2475,92,8,171),(2476,92,8,89),(2477,92,8,113),(2478,92,8,171),(2479,93,1,192),(2480,93,1,206),(2481,93,5,14),(2482,93,5,15),(2483,93,5,32),(2484,93,5,33),(2485,93,6,55),(2486,93,6,56),(2487,93,6,62),(2488,93,6,206),(2489,93,7,34),(2490,93,7,55),(2491,93,7,56),(2492,93,7,61),(2493,93,7,62),(2494,93,7,191),(2495,93,7,199),(2496,93,7,208),(2497,93,8,89),(2498,93,8,113),(2499,94,1,192),(2500,94,1,206),(2501,94,5,14),(2502,94,5,15),(2503,94,5,32),(2504,94,5,33),(2505,94,6,55),(2506,94,6,56),(2507,94,6,62),(2508,94,6,206),(2509,94,7,34),(2510,94,7,55),(2511,94,7,56),(2512,94,7,61),(2513,94,7,62),(2514,94,7,191),(2515,94,7,199),(2516,94,7,208),(2517,94,8,89),(2518,94,8,113),(2519,95,1,192),(2520,95,1,206),(2521,95,1,192),(2522,95,1,206),(2523,95,5,14),(2524,95,5,15),(2525,95,5,16),(2526,95,5,32),(2527,95,5,33),(2528,95,6,55),(2529,95,6,56),(2530,95,6,62),(2531,95,6,206),(2532,95,6,55),(2533,95,6,56),(2534,95,6,62),(2535,95,6,206),(2536,95,7,34),(2537,95,7,55),(2538,95,7,56),(2539,95,7,61),(2540,95,7,62),(2541,95,7,191),(2542,95,7,199),(2543,95,7,208),(2544,95,7,34),(2545,95,7,55),(2546,95,7,56),(2547,95,7,61),(2548,95,7,62),(2549,95,7,191),(2550,95,7,199),(2551,95,7,208),(2552,95,8,89),(2553,95,8,113),(2554,95,8,171),(2555,95,8,89),(2556,95,8,113),(2557,95,8,171),(2558,96,1,192),(2559,96,1,206),(2560,96,5,14),(2561,96,5,15),(2562,96,5,32),(2563,96,5,33),(2564,96,6,55),(2565,96,6,56),(2566,96,6,62),(2567,96,6,206),(2568,96,7,34),(2569,96,7,55),(2570,96,7,56),(2571,96,7,61),(2572,96,7,62),(2573,96,7,191),(2574,96,7,199),(2575,96,7,208),(2576,96,8,89),(2577,96,8,113),(2578,97,1,192),(2579,97,1,206),(2580,97,5,14),(2581,97,5,15),(2582,97,5,32),(2583,97,5,33),(2584,97,6,55),(2585,97,6,56),(2586,97,6,62),(2587,97,6,206),(2588,97,7,34),(2589,97,7,55),(2590,97,7,56),(2591,97,7,61),(2592,97,7,62),(2593,97,7,191),(2594,97,7,199),(2595,97,7,208),(2596,97,8,89),(2597,97,8,113),(2598,98,1,192),(2599,98,1,206),(2600,98,1,192),(2601,98,1,206),(2602,98,5,14),(2603,98,5,15),(2604,98,5,16),(2605,98,5,32),(2606,98,5,33),(2607,98,6,55),(2608,98,6,56),(2609,98,6,62),(2610,98,6,206),(2611,98,6,55),(2612,98,6,56),(2613,98,6,62),(2614,98,6,206),(2615,98,7,34),(2616,98,7,55),(2617,98,7,56),(2618,98,7,61),(2619,98,7,62),(2620,98,7,191),(2621,98,7,199),(2622,98,7,208),(2623,98,7,34),(2624,98,7,55),(2625,98,7,56),(2626,98,7,61),(2627,98,7,62),(2628,98,7,191),(2629,98,7,199),(2630,98,7,208),(2631,98,8,89),(2632,98,8,113),(2633,98,8,171),(2634,98,8,89),(2635,98,8,113),(2636,98,8,171),(2637,99,1,192),(2638,99,1,206),(2639,99,5,14),(2640,99,5,15),(2641,99,5,32),(2642,99,5,33),(2643,99,6,55),(2644,99,6,56),(2645,99,6,62),(2646,99,6,206),(2647,99,7,34),(2648,99,7,55),(2649,99,7,56),(2650,99,7,61),(2651,99,7,62),(2652,99,7,191),(2653,99,7,199),(2654,99,7,208),(2655,99,8,89),(2656,99,8,113),(2657,100,1,192),(2658,100,1,206),(2659,100,5,14),(2660,100,5,15),(2661,100,5,32),(2662,100,5,33),(2663,100,6,55),(2664,100,6,56),(2665,100,6,62),(2666,100,6,206),(2667,100,7,34),(2668,100,7,55),(2669,100,7,56),(2670,100,7,61),(2671,100,7,62),(2672,100,7,191),(2673,100,7,199),(2674,100,7,208),(2675,100,8,89),(2676,100,8,113),(2677,101,1,192),(2678,101,1,206),(2679,101,5,14),(2680,101,5,15),(2681,101,5,32),(2682,101,5,33),(2683,101,6,55),(2684,101,6,56),(2685,101,6,62),(2686,101,6,206),(2687,101,7,34),(2688,101,7,55),(2689,101,7,56),(2690,101,7,61),(2691,101,7,62),(2692,101,7,191),(2693,101,7,199),(2694,101,7,208),(2695,101,8,89),(2696,101,8,113),(2697,102,1,192),(2698,102,1,206),(2699,102,1,192),(2700,102,1,206),(2701,102,5,14),(2702,102,5,15),(2703,102,5,16),(2704,102,5,32),(2705,102,5,33),(2706,102,6,55),(2707,102,6,56),(2708,102,6,62),(2709,102,6,206),(2710,102,6,55),(2711,102,6,56),(2712,102,6,62),(2713,102,6,206),(2714,102,7,34),(2715,102,7,55),(2716,102,7,56),(2717,102,7,61),(2718,102,7,62),(2719,102,7,191),(2720,102,7,199),(2721,102,7,208),(2722,102,7,34),(2723,102,7,55),(2724,102,7,56),(2725,102,7,61),(2726,102,7,62),(2727,102,7,191),(2728,102,7,199),(2729,102,7,208),(2730,102,8,89),(2731,102,8,113),(2732,102,8,171),(2733,102,8,89),(2734,102,8,113),(2735,102,8,171),(2736,103,1,192),(2737,103,1,206),(2738,103,1,192),(2739,103,1,206),(2740,103,1,192),(2741,103,1,206),(2742,103,5,14),(2743,103,5,15),(2744,103,5,16),(2745,103,5,32),(2746,103,5,33),(2747,103,6,55),(2748,103,6,56),(2749,103,6,62),(2750,103,6,206),(2751,103,6,55),(2752,103,6,56),(2753,103,6,62),(2754,103,6,206),(2755,103,6,55),(2756,103,6,56),(2757,103,6,62),(2758,103,6,206),(2759,103,7,34),(2760,103,7,55),(2761,103,7,56),(2762,103,7,61),(2763,103,7,62),(2764,103,7,191),(2765,103,7,199),(2766,103,7,208),(2767,103,7,34),(2768,103,7,55),(2769,103,7,56),(2770,103,7,61),(2771,103,7,62),(2772,103,7,191),(2773,103,7,199),(2774,103,7,208),(2775,103,7,34),(2776,103,7,55),(2777,103,7,56),(2778,103,7,61),(2779,103,7,62),(2780,103,7,191),(2781,103,7,199),(2782,103,7,208),(2783,103,8,89),(2784,103,8,113),(2785,103,8,171),(2786,103,8,89),(2787,103,8,113),(2788,103,8,171),(2789,103,8,89),(2790,103,8,113),(2791,103,8,171),(2792,104,1,192),(2793,104,1,206),(2794,104,5,14),(2795,104,5,15),(2796,104,5,32),(2797,104,5,33),(2798,104,6,55),(2799,104,6,56),(2800,104,6,62),(2801,104,6,206),(2802,104,7,34),(2803,104,7,55),(2804,104,7,56),(2805,104,7,61),(2806,104,7,62),(2807,104,7,191),(2808,104,7,199),(2809,104,7,208),(2810,104,8,89),(2811,104,8,113),(2812,105,1,192),(2813,105,1,206),(2814,105,1,192),(2815,105,1,206),(2816,105,5,14),(2817,105,5,15),(2818,105,5,16),(2819,105,5,32),(2820,105,5,33),(2821,105,6,55),(2822,105,6,56),(2823,105,6,62),(2824,105,6,206),(2825,105,6,55),(2826,105,6,56),(2827,105,6,62),(2828,105,6,206),(2829,105,7,34),(2830,105,7,55),(2831,105,7,56),(2832,105,7,61),(2833,105,7,62),(2834,105,7,191),(2835,105,7,199),(2836,105,7,208),(2837,105,7,34),(2838,105,7,55),(2839,105,7,56),(2840,105,7,61),(2841,105,7,62),(2842,105,7,191),(2843,105,7,199),(2844,105,7,208),(2845,105,8,89),(2846,105,8,113),(2847,105,8,171),(2848,105,8,89),(2849,105,8,113),(2850,105,8,171),(2851,106,1,192),(2852,106,1,206),(2853,106,5,14),(2854,106,5,15),(2855,106,5,32),(2856,106,5,33),(2857,106,6,55),(2858,106,6,56),(2859,106,6,62),(2860,106,6,206),(2861,106,7,34),(2862,106,7,55),(2863,106,7,56),(2864,106,7,61),(2865,106,7,62),(2866,106,7,191),(2867,106,7,199),(2868,106,7,208),(2869,106,8,89),(2870,106,8,113),(2871,107,1,192),(2872,107,1,206),(2873,107,5,14),(2874,107,5,15),(2875,107,5,32),(2876,107,5,33),(2877,107,6,55),(2878,107,6,56),(2879,107,6,62),(2880,107,6,206),(2881,107,7,34),(2882,107,7,55),(2883,107,7,56),(2884,107,7,61),(2885,107,7,62),(2886,107,7,191),(2887,107,7,199),(2888,107,7,208),(2889,107,8,89),(2890,107,8,113),(2891,108,1,192),(2892,108,1,206),(2893,108,5,14),(2894,108,5,15),(2895,108,5,32),(2896,108,5,33),(2897,108,6,55),(2898,108,6,56),(2899,108,6,62),(2900,108,6,206),(2901,108,7,34),(2902,108,7,55),(2903,108,7,56),(2904,108,7,61),(2905,108,7,62),(2906,108,7,191),(2907,108,7,199),(2908,108,7,208),(2909,108,8,89),(2910,108,8,113),(2911,109,1,192),(2912,109,1,206),(2913,109,5,14),(2914,109,5,15),(2915,109,5,32),(2916,109,5,33),(2917,109,6,55),(2918,109,6,56),(2919,109,6,62),(2920,109,6,206),(2921,109,7,34),(2922,109,7,55),(2923,109,7,56),(2924,109,7,61),(2925,109,7,62),(2926,109,7,191),(2927,109,7,199),(2928,109,7,208),(2929,109,8,89),(2930,109,8,113),(2931,110,1,192),(2932,110,1,206),(2933,110,5,14),(2934,110,5,15),(2935,110,5,32),(2936,110,5,33),(2937,110,6,55),(2938,110,6,56),(2939,110,6,62),(2940,110,6,206),(2941,110,7,34),(2942,110,7,55),(2943,110,7,56),(2944,110,7,61),(2945,110,7,62),(2946,110,7,191),(2947,110,7,199),(2948,110,7,208),(2949,110,8,89),(2950,110,8,113),(2951,111,1,192),(2952,111,1,206),(2953,111,5,14),(2954,111,5,15),(2955,111,5,32),(2956,111,5,33),(2957,111,6,55),(2958,111,6,56),(2959,111,6,62),(2960,111,6,206),(2961,111,7,34),(2962,111,7,55),(2963,111,7,56),(2964,111,7,61),(2965,111,7,62),(2966,111,7,191),(2967,111,7,199),(2968,111,7,208),(2969,111,8,89),(2970,111,8,113),(2971,112,1,192),(2972,112,1,206),(2973,112,5,14),(2974,112,5,15),(2975,112,5,32),(2976,112,5,33),(2977,112,6,55),(2978,112,6,56),(2979,112,6,62),(2980,112,6,206),(2981,112,7,34),(2982,112,7,55),(2983,112,7,56),(2984,112,7,61),(2985,112,7,62),(2986,112,7,191),(2987,112,7,199),(2988,112,7,208),(2989,112,8,89),(2990,112,8,113),(2991,113,1,192),(2992,113,1,206),(2993,113,5,14),(2994,113,5,15),(2995,113,5,32),(2996,113,5,33),(2997,113,6,55),(2998,113,6,56),(2999,113,6,62),(3000,113,6,206),(3001,113,7,34),(3002,113,7,55),(3003,113,7,56),(3004,113,7,61),(3005,113,7,62),(3006,113,7,191),(3007,113,7,199),(3008,113,7,208),(3009,113,8,89),(3010,113,8,113),(3011,114,1,192),(3012,114,1,206),(3013,114,1,192),(3014,114,1,206),(3015,114,5,14),(3016,114,5,15),(3017,114,5,16),(3018,114,5,32),(3019,114,5,33),(3020,114,6,55),(3021,114,6,56),(3022,114,6,62),(3023,114,6,206),(3024,114,6,55),(3025,114,6,56),(3026,114,6,62),(3027,114,6,206),(3028,114,7,34),(3029,114,7,55),(3030,114,7,56),(3031,114,7,61),(3032,114,7,62),(3033,114,7,191),(3034,114,7,199),(3035,114,7,208),(3036,114,7,34),(3037,114,7,55),(3038,114,7,56),(3039,114,7,61),(3040,114,7,62),(3041,114,7,191),(3042,114,7,199),(3043,114,7,208),(3044,114,8,89),(3045,114,8,113),(3046,114,8,171),(3047,114,8,89),(3048,114,8,113),(3049,114,8,171),(3050,115,1,192),(3051,115,1,206),(3052,115,5,14),(3053,115,5,15),(3054,115,5,32),(3055,115,5,33),(3056,115,6,55),(3057,115,6,56),(3058,115,6,62),(3059,115,6,206),(3060,115,7,34),(3061,115,7,55),(3062,115,7,56),(3063,115,7,61),(3064,115,7,62),(3065,115,7,191),(3066,115,7,199),(3067,115,7,208),(3068,115,8,89),(3069,115,8,113),(3070,116,1,192),(3071,116,1,206),(3072,116,1,192),(3073,116,1,206),(3074,116,5,14),(3075,116,5,15),(3076,116,5,16),(3077,116,5,32),(3078,116,5,33),(3079,116,6,55),(3080,116,6,56),(3081,116,6,62),(3082,116,6,206),(3083,116,6,55),(3084,116,6,56),(3085,116,6,62),(3086,116,6,206),(3087,116,7,34),(3088,116,7,55),(3089,116,7,56),(3090,116,7,61),(3091,116,7,62),(3092,116,7,191),(3093,116,7,199),(3094,116,7,208),(3095,116,7,34),(3096,116,7,55),(3097,116,7,56),(3098,116,7,61),(3099,116,7,62),(3100,116,7,191),(3101,116,7,199),(3102,116,7,208),(3103,116,8,89),(3104,116,8,113),(3105,116,8,171),(3106,116,8,89),(3107,116,8,113),(3108,116,8,171),(3109,117,1,192),(3110,117,1,206),(3111,117,5,14),(3112,117,5,15),(3113,117,5,32),(3114,117,5,33),(3115,117,6,55),(3116,117,6,56),(3117,117,6,62),(3118,117,6,206),(3119,117,7,34),(3120,117,7,55),(3121,117,7,56),(3122,117,7,61),(3123,117,7,62),(3124,117,7,191),(3125,117,7,199),(3126,117,7,208),(3127,117,8,89),(3128,117,8,113),(3129,118,1,192),(3130,118,1,206),(3131,118,1,192),(3132,118,1,206),(3133,118,5,14),(3134,118,5,15),(3135,118,5,16),(3136,118,5,32),(3137,118,5,33),(3138,118,6,55),(3139,118,6,56),(3140,118,6,62),(3141,118,6,206),(3142,118,6,55),(3143,118,6,56),(3144,118,6,62),(3145,118,6,206),(3146,118,7,34),(3147,118,7,55),(3148,118,7,56),(3149,118,7,61),(3150,118,7,62),(3151,118,7,191),(3152,118,7,199),(3153,118,7,208),(3154,118,7,34),(3155,118,7,55),(3156,118,7,56),(3157,118,7,61),(3158,118,7,62),(3159,118,7,191),(3160,118,7,199),(3161,118,7,208),(3162,118,8,89),(3163,118,8,113),(3164,118,8,171),(3165,118,8,89),(3166,118,8,113),(3167,118,8,171),(3168,119,1,192),(3169,119,1,206),(3170,119,1,192),(3171,119,1,206),(3172,119,1,192),(3173,119,1,206),(3174,119,5,14),(3175,119,5,15),(3176,119,5,16),(3177,119,5,32),(3178,119,5,33),(3179,119,6,55),(3180,119,6,56),(3181,119,6,62),(3182,119,6,206),(3183,119,6,55),(3184,119,6,56),(3185,119,6,62),(3186,119,6,206),(3187,119,6,55),(3188,119,6,56),(3189,119,6,62),(3190,119,6,206),(3191,119,7,34),(3192,119,7,55),(3193,119,7,56),(3194,119,7,61),(3195,119,7,62),(3196,119,7,191),(3197,119,7,199),(3198,119,7,208),(3199,119,7,34),(3200,119,7,55),(3201,119,7,56),(3202,119,7,61),(3203,119,7,62),(3204,119,7,191),(3205,119,7,199),(3206,119,7,208),(3207,119,7,34),(3208,119,7,55),(3209,119,7,56),(3210,119,7,61),(3211,119,7,62),(3212,119,7,191),(3213,119,7,199),(3214,119,7,208),(3215,119,8,89),(3216,119,8,113),(3217,119,8,171),(3218,119,8,89),(3219,119,8,113),(3220,119,8,171),(3221,119,8,89),(3222,119,8,113),(3223,119,8,171),(3224,120,1,192),(3225,120,1,206),(3226,120,1,192),(3227,120,1,206),(3228,120,1,192),(3229,120,1,206),(3230,120,5,14),(3231,120,5,15),(3232,120,5,16),(3233,120,5,32),(3234,120,5,33),(3235,120,6,55),(3236,120,6,56),(3237,120,6,62),(3238,120,6,206),(3239,120,6,55),(3240,120,6,56),(3241,120,6,62),(3242,120,6,206),(3243,120,6,55),(3244,120,6,56),(3245,120,6,62),(3246,120,6,206),(3247,120,7,34),(3248,120,7,55),(3249,120,7,56),(3250,120,7,61),(3251,120,7,62),(3252,120,7,191),(3253,120,7,199),(3254,120,7,208),(3255,120,7,34),(3256,120,7,55),(3257,120,7,56),(3258,120,7,61),(3259,120,7,62),(3260,120,7,191),(3261,120,7,199),(3262,120,7,208),(3263,120,7,34),(3264,120,7,55),(3265,120,7,56),(3266,120,7,61),(3267,120,7,62),(3268,120,7,191),(3269,120,7,199),(3270,120,7,208),(3271,120,8,89),(3272,120,8,113),(3273,120,8,171),(3274,120,8,89),(3275,120,8,113),(3276,120,8,171),(3277,120,8,89),(3278,120,8,113),(3279,120,8,171),(3280,122,1,-1),(3281,122,1,-1),(3282,122,5,-1),(3283,122,5,-1),(3284,122,5,-1),(3285,122,5,-1),(3286,122,6,-1),(3287,122,6,-1),(3288,122,6,-1),(3289,122,6,-1),(3290,122,7,-1),(3291,122,7,-1),(3292,122,7,-1),(3293,122,7,-1),(3294,122,7,-1),(3295,122,7,-1),(3296,122,7,-1),(3297,122,7,-1),(3298,122,8,-1),(3299,122,8,-1),(3300,123,1,-1),(3301,123,1,-1),(3302,123,1,-1),(3303,123,1,-1),(3304,123,5,-1),(3305,123,5,-1),(3306,123,5,-1),(3307,123,5,-1),(3308,123,5,-1),(3309,123,6,-1),(3310,123,6,-1),(3311,123,6,-1),(3312,123,6,-1),(3313,123,6,-1),(3314,123,6,-1),(3315,123,6,-1),(3316,123,6,-1),(3317,123,7,-1),(3318,123,7,-1),(3319,123,7,-1),(3320,123,7,-1),(3321,123,7,-1),(3322,123,7,-1),(3323,123,7,-1),(3324,123,7,-1),(3325,123,7,-1),(3326,123,7,-1),(3327,123,7,-1),(3328,123,7,-1),(3329,123,7,-1),(3330,123,7,-1),(3331,123,7,-1),(3332,123,7,-1),(3333,123,8,-1),(3334,123,8,-1),(3335,123,8,-1),(3336,123,8,-1),(3337,123,8,-1),(3338,123,8,-1),(3339,124,1,192),(3340,124,1,206),(3341,124,5,14),(3342,124,5,15),(3343,124,5,32),(3344,124,5,33),(3345,124,6,55),(3346,124,6,56),(3347,124,6,62),(3348,124,6,206),(3349,124,7,34),(3350,124,7,55),(3351,124,7,56),(3352,124,7,61),(3353,124,7,62),(3354,124,7,191),(3355,124,7,199),(3356,124,7,208),(3357,124,8,89),(3358,124,8,113),(3359,125,1,192),(3360,125,1,206),(3361,125,5,14),(3362,125,5,15),(3363,125,5,32),(3364,125,5,33),(3365,125,6,55),(3366,125,6,56),(3367,125,6,62),(3368,125,6,206),(3369,125,7,34),(3370,125,7,55),(3371,125,7,56),(3372,125,7,61),(3373,125,7,62),(3374,125,7,191),(3375,125,7,199),(3376,125,7,208),(3377,125,8,89),(3378,125,8,113),(3379,126,1,192),(3380,126,1,206),(3381,126,1,192),(3382,126,1,206),(3383,126,5,14),(3384,126,5,15),(3385,126,5,16),(3386,126,5,32),(3387,126,5,33),(3388,126,6,55),(3389,126,6,56),(3390,126,6,62),(3391,126,6,206),(3392,126,6,55),(3393,126,6,56),(3394,126,6,62),(3395,126,6,206),(3396,126,7,34),(3397,126,7,55),(3398,126,7,56),(3399,126,7,61),(3400,126,7,62),(3401,126,7,191),(3402,126,7,199),(3403,126,7,208),(3404,126,7,34),(3405,126,7,55),(3406,126,7,56),(3407,126,7,61),(3408,126,7,62),(3409,126,7,191),(3410,126,7,199),(3411,126,7,208),(3412,126,8,89),(3413,126,8,113),(3414,126,8,171),(3415,126,8,89),(3416,126,8,113),(3417,126,8,171),(3418,127,1,192),(3419,127,1,206),(3420,127,1,192),(3421,127,1,206),(3422,127,1,192),(3423,127,1,206),(3424,127,5,14),(3425,127,5,15),(3426,127,5,16),(3427,127,5,32),(3428,127,5,33),(3429,127,6,55),(3430,127,6,56),(3431,127,6,62),(3432,127,6,206),(3433,127,6,55),(3434,127,6,56),(3435,127,6,62),(3436,127,6,206),(3437,127,6,55),(3438,127,6,56),(3439,127,6,62),(3440,127,6,206),(3441,127,7,34),(3442,127,7,55),(3443,127,7,56),(3444,127,7,61),(3445,127,7,62),(3446,127,7,191),(3447,127,7,199),(3448,127,7,208),(3449,127,7,34),(3450,127,7,55),(3451,127,7,56),(3452,127,7,61),(3453,127,7,62),(3454,127,7,191),(3455,127,7,199),(3456,127,7,208),(3457,127,7,34),(3458,127,7,55),(3459,127,7,56),(3460,127,7,61),(3461,127,7,62),(3462,127,7,191),(3463,127,7,199),(3464,127,7,208),(3465,127,8,89),(3466,127,8,113),(3467,127,8,171),(3468,127,8,89),(3469,127,8,113),(3470,127,8,171),(3471,127,8,89),(3472,127,8,113),(3473,127,8,171),(3474,128,1,192),(3475,128,1,206),(3476,128,5,14),(3477,128,5,15),(3478,128,5,32),(3479,128,5,33),(3480,128,6,55),(3481,128,6,56),(3482,128,6,62),(3483,128,6,206),(3484,128,7,34),(3485,128,7,55),(3486,128,7,56),(3487,128,7,61),(3488,128,7,62),(3489,128,7,191),(3490,128,7,199),(3491,128,7,208),(3492,128,8,89),(3493,128,8,113),(3494,129,1,192),(3495,129,1,206),(3496,129,5,14),(3497,129,5,15),(3498,129,5,32),(3499,129,5,33),(3500,129,6,55),(3501,129,6,56),(3502,129,6,62),(3503,129,6,206),(3504,129,7,34),(3505,129,7,55),(3506,129,7,56),(3507,129,7,61),(3508,129,7,62),(3509,129,7,191),(3510,129,7,199),(3511,129,7,208),(3512,129,8,89),(3513,129,8,113),(3514,130,1,192),(3515,130,1,206),(3516,130,1,192),(3517,130,1,206),(3518,130,5,14),(3519,130,5,15),(3520,130,5,16),(3521,130,5,32),(3522,130,5,33),(3523,130,6,55),(3524,130,6,56),(3525,130,6,62),(3526,130,6,206),(3527,130,6,55),(3528,130,6,56),(3529,130,6,62),(3530,130,6,206),(3531,130,7,34),(3532,130,7,55),(3533,130,7,56),(3534,130,7,61),(3535,130,7,62),(3536,130,7,191),(3537,130,7,199),(3538,130,7,208),(3539,130,7,34),(3540,130,7,55),(3541,130,7,56),(3542,130,7,61),(3543,130,7,62),(3544,130,7,191),(3545,130,7,199),(3546,130,7,208),(3547,130,8,89),(3548,130,8,113),(3549,130,8,171),(3550,130,8,89),(3551,130,8,113),(3552,130,8,171),(3553,131,1,192),(3554,131,1,206),(3555,131,1,192),(3556,131,1,206),(3557,131,1,192),(3558,131,1,206),(3559,131,5,14),(3560,131,5,15),(3561,131,5,16),(3562,131,5,32),(3563,131,5,33),(3564,131,6,55),(3565,131,6,56),(3566,131,6,62),(3567,131,6,206),(3568,131,6,55),(3569,131,6,56),(3570,131,6,62),(3571,131,6,206),(3572,131,6,55),(3573,131,6,56),(3574,131,6,62),(3575,131,6,206),(3576,131,7,34),(3577,131,7,55),(3578,131,7,56),(3579,131,7,61),(3580,131,7,62),(3581,131,7,191),(3582,131,7,199),(3583,131,7,208),(3584,131,7,34),(3585,131,7,55),(3586,131,7,56),(3587,131,7,61),(3588,131,7,62),(3589,131,7,191),(3590,131,7,199),(3591,131,7,208),(3592,131,7,34),(3593,131,7,55),(3594,131,7,56),(3595,131,7,61),(3596,131,7,62),(3597,131,7,191),(3598,131,7,199),(3599,131,7,208),(3600,131,8,89),(3601,131,8,113),(3602,131,8,171),(3603,131,8,89),(3604,131,8,113),(3605,131,8,171),(3606,131,8,89),(3607,131,8,113),(3608,131,8,171),(3609,132,1,192),(3610,132,1,206),(3611,132,1,192),(3612,132,1,206),(3613,132,1,192),(3614,132,1,206),(3615,132,1,192),(3616,132,1,206),(3617,132,5,14),(3618,132,5,15),(3619,132,5,16),(3620,132,5,32),(3621,132,5,33),(3622,132,6,55),(3623,132,6,56),(3624,132,6,62),(3625,132,6,206),(3626,132,6,55),(3627,132,6,56),(3628,132,6,62),(3629,132,6,206),(3630,132,6,55),(3631,132,6,56),(3632,132,6,62),(3633,132,6,206),(3634,132,6,55),(3635,132,6,56),(3636,132,6,62),(3637,132,6,206),(3638,132,7,34),(3639,132,7,55),(3640,132,7,56),(3641,132,7,61),(3642,132,7,62),(3643,132,7,191),(3644,132,7,199),(3645,132,7,208),(3646,132,7,34),(3647,132,7,55),(3648,132,7,56),(3649,132,7,61),(3650,132,7,62),(3651,132,7,191),(3652,132,7,199),(3653,132,7,208),(3654,132,7,34),(3655,132,7,55),(3656,132,7,56),(3657,132,7,61),(3658,132,7,62),(3659,132,7,191),(3660,132,7,199),(3661,132,7,208),(3662,132,7,34),(3663,132,7,55),(3664,132,7,56),(3665,132,7,61),(3666,132,7,62),(3667,132,7,191),(3668,132,7,199),(3669,132,7,208),(3670,132,8,89),(3671,132,8,113),(3672,132,8,171),(3673,132,8,89),(3674,132,8,113),(3675,132,8,171),(3676,132,8,89),(3677,132,8,113),(3678,132,8,171),(3679,132,8,89),(3680,132,8,113),(3681,132,8,171),(3682,133,1,192),(3683,133,1,206),(3684,133,1,192),(3685,133,1,206),(3686,133,1,192),(3687,133,1,206),(3688,133,1,192),(3689,133,1,206),(3690,133,1,192),(3691,133,1,206),(3692,133,5,14),(3693,133,5,15),(3694,133,5,16),(3695,133,5,32),(3696,133,5,33),(3697,133,6,55),(3698,133,6,56),(3699,133,6,62),(3700,133,6,206),(3701,133,6,55),(3702,133,6,56),(3703,133,6,62),(3704,133,6,206),(3705,133,6,55),(3706,133,6,56),(3707,133,6,62),(3708,133,6,206),(3709,133,6,55),(3710,133,6,56),(3711,133,6,62),(3712,133,6,206),(3713,133,6,55),(3714,133,6,56),(3715,133,6,62),(3716,133,6,206),(3717,133,7,34),(3718,133,7,55),(3719,133,7,56),(3720,133,7,61),(3721,133,7,62),(3722,133,7,191),(3723,133,7,199),(3724,133,7,208),(3725,133,7,34),(3726,133,7,55),(3727,133,7,56),(3728,133,7,61),(3729,133,7,62),(3730,133,7,191),(3731,133,7,199),(3732,133,7,208),(3733,133,7,34),(3734,133,7,55),(3735,133,7,56),(3736,133,7,61),(3737,133,7,62),(3738,133,7,191),(3739,133,7,199),(3740,133,7,208),(3741,133,7,34),(3742,133,7,55),(3743,133,7,56),(3744,133,7,61),(3745,133,7,62),(3746,133,7,191),(3747,133,7,199),(3748,133,7,208),(3749,133,7,34),(3750,133,7,55),(3751,133,7,56),(3752,133,7,61),(3753,133,7,62),(3754,133,7,191),(3755,133,7,199),(3756,133,7,208),(3757,133,8,89),(3758,133,8,113),(3759,133,8,171),(3760,133,8,89),(3761,133,8,113),(3762,133,8,171),(3763,133,8,89),(3764,133,8,113),(3765,133,8,171),(3766,133,8,89),(3767,133,8,113),(3768,133,8,171),(3769,133,8,89),(3770,133,8,113),(3771,133,8,171),(3772,134,1,192),(3773,134,1,206),(3774,134,5,14),(3775,134,5,15),(3776,134,5,32),(3777,134,5,33),(3778,134,6,55),(3779,134,6,56),(3780,134,6,62),(3781,134,6,206),(3782,134,7,34),(3783,134,7,55),(3784,134,7,56),(3785,134,7,61),(3786,134,7,62),(3787,134,7,191),(3788,134,7,199),(3789,134,7,208),(3790,134,8,89),(3791,134,8,113),(3792,135,1,192),(3793,135,1,206),(3794,135,5,14),(3795,135,5,15),(3796,135,5,32),(3797,135,5,33),(3798,135,6,55),(3799,135,6,56),(3800,135,6,62),(3801,135,6,206),(3802,135,7,34),(3803,135,7,55),(3804,135,7,56),(3805,135,7,61),(3806,135,7,62),(3807,135,7,191),(3808,135,7,199),(3809,135,7,208),(3810,135,8,89),(3811,135,8,113),(3812,136,1,192),(3813,136,1,206),(3814,136,5,14),(3815,136,5,15),(3816,136,5,32),(3817,136,5,33),(3818,136,6,55),(3819,136,6,56),(3820,136,6,62),(3821,136,6,206),(3822,136,7,34),(3823,136,7,55),(3824,136,7,56),(3825,136,7,61),(3826,136,7,62),(3827,136,7,191),(3828,136,7,199),(3829,136,7,208),(3830,136,8,89),(3831,136,8,113),(3832,137,1,192),(3833,137,1,206),(3834,137,5,14),(3835,137,5,15),(3836,137,5,32),(3837,137,5,33),(3838,137,6,55),(3839,137,6,56),(3840,137,6,62),(3841,137,6,206),(3842,137,7,34),(3843,137,7,55),(3844,137,7,56),(3845,137,7,61),(3846,137,7,62),(3847,137,7,191),(3848,137,7,199),(3849,137,7,208),(3850,137,8,89),(3851,137,8,113),(3852,138,1,192),(3853,138,1,206),(3854,138,5,14),(3855,138,5,15),(3856,138,5,32),(3857,138,5,33),(3858,138,6,55),(3859,138,6,56),(3860,138,6,62),(3861,138,6,206),(3862,138,7,34),(3863,138,7,55),(3864,138,7,56),(3865,138,7,61),(3866,138,7,62),(3867,138,7,191),(3868,138,7,199),(3869,138,7,208),(3870,138,8,89),(3871,138,8,113),(3872,141,1,-1),(3873,141,1,-1),(3874,141,5,18),(3875,141,5,18),(3876,141,5,28),(3877,141,5,29),(3878,141,6,45),(3879,141,6,46),(3880,141,6,52),(3881,141,6,-1),(3882,141,7,32),(3883,141,7,45),(3884,141,7,46),(3885,141,7,51),(3886,141,7,52),(3887,141,7,-1),(3888,141,7,-1),(3889,141,7,-1),(3890,141,8,73),(3891,141,8,86),(3892,142,1,192),(3893,142,1,206),(3894,142,5,14),(3895,142,5,15),(3896,142,5,32),(3897,142,5,33),(3898,142,6,55),(3899,142,6,56),(3900,142,6,62),(3901,142,6,206),(3902,142,7,34),(3903,142,7,55),(3904,142,7,56),(3905,142,7,61),(3906,142,7,62),(3907,142,7,191),(3908,142,7,199),(3909,142,7,208),(3910,142,8,89),(3911,142,8,113),(3912,166,1,-1),(3913,166,1,-1),(3914,166,5,18),(3915,166,5,18),(3916,166,5,28),(3917,166,5,29),(3918,166,6,45),(3919,166,6,46),(3920,166,6,52),(3921,166,6,-1),(3922,166,7,32),(3923,166,7,45),(3924,166,7,46),(3925,166,7,51),(3926,166,7,52),(3927,166,7,-1),(3928,166,7,-1),(3929,166,7,-1),(3930,166,8,73),(3931,166,8,86),(3932,174,1,-1),(3933,174,1,-1),(3934,174,5,18),(3935,174,5,18),(3936,174,5,28),(3937,174,5,29),(3938,174,6,45),(3939,174,6,46),(3940,174,6,52),(3941,174,6,-1),(3942,174,7,32),(3943,174,7,45),(3944,174,7,46),(3945,174,7,51),(3946,174,7,52),(3947,174,7,-1),(3948,174,7,-1),(3949,174,7,-1),(3950,174,8,73),(3951,174,8,86),(3952,176,1,-1),(3953,176,1,-1),(3954,176,5,18),(3955,176,5,18),(3956,176,5,28),(3957,176,5,29),(3958,176,6,45),(3959,176,6,46),(3960,176,6,52),(3961,176,6,-1),(3962,176,7,32),(3963,176,7,45),(3964,176,7,46),(3965,176,7,51),(3966,176,7,52),(3967,176,7,-1),(3968,176,7,-1),(3969,176,7,-1),(3970,176,8,73),(3971,176,8,86),(3972,177,1,-1),(3973,177,1,-1),(3974,177,1,-1),(3975,177,1,-1),(3976,177,5,18),(3977,177,5,18),(3978,177,5,18),(3979,177,5,28),(3980,177,5,29),(3981,177,6,45),(3982,177,6,46),(3983,177,6,52),(3984,177,6,-1),(3985,177,6,45),(3986,177,6,46),(3987,177,6,52),(3988,177,6,-1),(3989,177,7,32),(3990,177,7,45),(3991,177,7,46),(3992,177,7,51),(3993,177,7,52),(3994,177,7,-1),(3995,177,7,-1),(3996,177,7,-1),(3997,177,7,32),(3998,177,7,45),(3999,177,7,46),(4000,177,7,51),(4001,177,7,52),(4002,177,7,-1),(4003,177,7,-1),(4004,177,7,-1),(4005,177,8,73),(4006,177,8,86),(4007,177,8,-1),(4008,177,8,73),(4009,177,8,86),(4010,177,8,-1),(4011,178,1,192),(4012,178,1,206),(4013,178,5,14),(4014,178,5,15),(4015,178,5,32),(4016,178,5,33),(4017,178,6,55),(4018,178,6,56),(4019,178,6,62),(4020,178,6,206),(4021,178,7,34),(4022,178,7,55),(4023,178,7,56),(4024,178,7,61),(4025,178,7,62),(4026,178,7,191),(4027,178,7,199),(4028,178,7,208),(4029,178,8,89),(4030,178,8,113),(4031,180,1,-1),(4032,180,1,-1),(4033,180,5,18),(4034,180,5,18),(4035,180,5,28),(4036,180,5,29),(4037,180,6,45),(4038,180,6,46),(4039,180,6,52),(4040,180,6,-1),(4041,180,7,32),(4042,180,7,45),(4043,180,7,46),(4044,180,7,51),(4045,180,7,52),(4046,180,7,-1),(4047,180,7,-1),(4048,180,7,-1),(4049,180,8,73),(4050,180,8,86),(4051,182,1,10),(4052,182,7,9),(4053,183,6,9),(4054,184,6,12),(4055,185,7,8),(4056,186,8,26),(4057,187,8,24),(4058,188,8,24),(4059,189,8,24),(4060,190,8,26),(4061,191,8,27),(4062,192,7,47),(4063,192,8,27),(4064,193,5,14),(4065,193,5,15),(4066,193,5,32),(4067,193,5,33),(4068,193,6,55),(4069,193,6,56),(4070,193,6,62),(4071,193,7,34),(4072,193,7,55),(4073,193,7,56),(4074,193,7,61),(4075,193,7,62),(4076,193,8,89),(4077,194,1,-1),(4078,194,1,-1),(4079,194,5,14),(4080,194,5,15),(4081,194,5,16),(4082,194,5,32),(4083,194,5,33),(4084,194,6,55),(4085,194,6,56),(4086,194,6,62),(4087,194,6,55),(4088,194,6,56),(4089,194,6,62),(4090,194,6,-1),(4091,194,7,34),(4092,194,7,55),(4093,194,7,56),(4094,194,7,61),(4095,194,7,62),(4096,194,7,34),(4097,194,7,55),(4098,194,7,56),(4099,194,7,61),(4100,194,7,62),(4101,194,7,-1),(4102,194,7,-1),(4103,194,7,-1),(4104,194,8,89),(4105,194,8,89),(4106,194,8,-1),(4107,195,1,192),(4108,195,1,206),(4109,195,5,14),(4110,195,5,15),(4111,195,5,32),(4112,195,5,33),(4113,195,6,55),(4114,195,6,56),(4115,195,6,62),(4116,195,6,206),(4117,195,7,34),(4118,195,7,55),(4119,195,7,56),(4120,195,7,61),(4121,195,7,62),(4122,195,7,191),(4123,195,7,199),(4124,195,7,208),(4125,195,8,89),(4126,195,8,113),(4127,196,7,8),(4128,199,1,16),(4129,199,7,12),(4130,200,1,10),(4131,200,7,9),(4132,201,1,10),(4133,201,1,10),(4134,201,7,9),(4135,201,7,9),(4136,202,1,10),(4137,202,1,10),(4138,202,6,9),(4139,202,7,9),(4140,202,7,9),(4141,203,6,9),(4142,204,1,-1),(4143,204,1,-1),(4144,204,5,10),(4145,204,5,10),(4146,204,5,-1),(4147,204,5,-1),(4148,204,6,9),(4149,204,6,-1),(4150,204,6,-1),(4151,204,6,-1),(4152,204,6,-1),(4153,204,7,-1),(4154,204,7,-1),(4155,204,7,-1),(4156,204,7,-1),(4157,204,7,-1),(4158,204,7,-1),(4159,204,7,-1),(4160,204,7,-1),(4161,204,8,-1),(4162,204,8,-1),(4163,205,1,192),(4164,205,1,206),(4165,205,5,14),(4166,205,5,15),(4167,205,5,32),(4168,205,5,33),(4169,205,6,55),(4170,205,6,56),(4171,205,6,62),(4172,205,6,206),(4173,205,7,34),(4174,205,7,55),(4175,205,7,56),(4176,205,7,61),(4177,205,7,62),(4178,205,7,191),(4179,205,7,199),(4180,205,7,208),(4181,205,8,89),(4182,205,8,113),(4183,206,1,192),(4184,206,1,206),(4185,206,5,14),(4186,206,5,15),(4187,206,5,32),(4188,206,5,33),(4189,206,5,14),(4190,206,5,30),(4191,206,5,31),(4192,206,6,55),(4193,206,6,56),(4194,206,6,62),(4195,206,6,206),(4196,206,7,34),(4197,206,7,55),(4198,206,7,56),(4199,206,7,61),(4200,206,7,62),(4201,206,7,191),(4202,206,7,199),(4203,206,7,208),(4204,206,7,32),(4205,206,8,89),(4206,206,8,113),(4207,207,5,13),(4208,207,5,14),(4209,207,5,30),(4210,207,5,31),(4211,207,7,32),(4212,208,5,13),(4213,208,5,14),(4214,208,5,30),(4215,208,5,31),(4216,208,5,13),(4217,208,5,14),(4218,208,5,30),(4219,208,5,31),(4220,208,7,32),(4221,208,7,32),(4222,209,5,12),(4223,209,5,13),(4224,209,5,29),(4225,209,5,30),(4226,209,7,31),(4227,210,5,13),(4228,210,5,14),(4229,210,5,31),(4230,210,5,32),(4231,210,7,33),(4232,211,5,12),(4233,211,5,13),(4234,211,5,30),(4235,211,5,31),(4236,211,7,32),(4237,212,5,13),(4238,212,5,14),(4239,212,5,31),(4240,212,5,32),(4241,212,7,33),(4242,213,5,13),(4243,213,5,14),(4244,213,5,31),(4245,213,5,32),(4246,213,5,13),(4247,213,5,14),(4248,213,5,30),(4249,213,5,32),(4250,213,7,33),(4251,213,7,33),(4252,214,6,12),(4253,215,7,12),(4254,216,8,26),(4255,217,1,192),(4256,217,1,206),(4257,217,5,14),(4258,217,5,15),(4259,217,5,32),(4260,217,5,33),(4261,217,6,55),(4262,217,6,56),(4263,217,6,62),(4264,217,6,206),(4265,217,7,34),(4266,217,7,55),(4267,217,7,56),(4268,217,7,61),(4269,217,7,62),(4270,217,7,191),(4271,217,7,199),(4272,217,7,208),(4273,217,8,89),(4274,217,8,113),(4275,218,1,192),(4276,218,1,206),(4277,218,1,192),(4278,218,1,206),(4279,218,5,14),(4280,218,5,15),(4281,218,5,16),(4282,218,5,32),(4283,218,5,33),(4284,218,6,55),(4285,218,6,56),(4286,218,6,62),(4287,218,6,206),(4288,218,6,55),(4289,218,6,56),(4290,218,6,62),(4291,218,6,206),(4292,218,7,34),(4293,218,7,55),(4294,218,7,56),(4295,218,7,61),(4296,218,7,62),(4297,218,7,191),(4298,218,7,199),(4299,218,7,208),(4300,218,7,34),(4301,218,7,55),(4302,218,7,56),(4303,218,7,61),(4304,218,7,62),(4305,218,7,191),(4306,218,7,199),(4307,218,7,208),(4308,218,8,89),(4309,218,8,113),(4310,218,8,171),(4311,218,8,89),(4312,218,8,113),(4313,218,8,171),(4314,219,1,192),(4315,219,1,206),(4316,219,1,192),(4317,219,1,206),(4318,219,1,192),(4319,219,1,206),(4320,219,5,14),(4321,219,5,15),(4322,219,5,16),(4323,219,5,32),(4324,219,5,33),(4325,219,6,55),(4326,219,6,56),(4327,219,6,62),(4328,219,6,206),(4329,219,6,55),(4330,219,6,56),(4331,219,6,62),(4332,219,6,206),(4333,219,6,55),(4334,219,6,56),(4335,219,6,62),(4336,219,6,206),(4337,219,7,34),(4338,219,7,55),(4339,219,7,56),(4340,219,7,61),(4341,219,7,62),(4342,219,7,191),(4343,219,7,199),(4344,219,7,208),(4345,219,7,34),(4346,219,7,55),(4347,219,7,56),(4348,219,7,61),(4349,219,7,62),(4350,219,7,191),(4351,219,7,199),(4352,219,7,208),(4353,219,7,34),(4354,219,7,55),(4355,219,7,56),(4356,219,7,61),(4357,219,7,62),(4358,219,7,191),(4359,219,7,199),(4360,219,7,208),(4361,219,8,89),(4362,219,8,113),(4363,219,8,171),(4364,219,8,89),(4365,219,8,113),(4366,219,8,171),(4367,219,8,89),(4368,219,8,113),(4369,219,8,171),(4370,220,1,192),(4371,220,1,206),(4372,220,1,192),(4373,220,1,206),(4374,220,1,192),(4375,220,1,206),(4376,220,1,192),(4377,220,1,206),(4378,220,5,14),(4379,220,5,15),(4380,220,5,16),(4381,220,5,32),(4382,220,5,33),(4383,220,6,55),(4384,220,6,56),(4385,220,6,62),(4386,220,6,206),(4387,220,6,55),(4388,220,6,56),(4389,220,6,62),(4390,220,6,206),(4391,220,6,55),(4392,220,6,56),(4393,220,6,62),(4394,220,6,206),(4395,220,6,55),(4396,220,6,56),(4397,220,6,62),(4398,220,6,206),(4399,220,7,34),(4400,220,7,55),(4401,220,7,56),(4402,220,7,61),(4403,220,7,62),(4404,220,7,191),(4405,220,7,199),(4406,220,7,208),(4407,220,7,34),(4408,220,7,55),(4409,220,7,56),(4410,220,7,61),(4411,220,7,62),(4412,220,7,191),(4413,220,7,199),(4414,220,7,208),(4415,220,7,34),(4416,220,7,55),(4417,220,7,56),(4418,220,7,61),(4419,220,7,62),(4420,220,7,191),(4421,220,7,199),(4422,220,7,208),(4423,220,7,34),(4424,220,7,55),(4425,220,7,56),(4426,220,7,61),(4427,220,7,62),(4428,220,7,191),(4429,220,7,199),(4430,220,7,208),(4431,220,8,89),(4432,220,8,113),(4433,220,8,171),(4434,220,8,89),(4435,220,8,113),(4436,220,8,171),(4437,220,8,89),(4438,220,8,113),(4439,220,8,171),(4440,220,8,89),(4441,220,8,113),(4442,220,8,171),(4443,221,1,192),(4444,221,1,206),(4445,221,1,192),(4446,221,1,206),(4447,221,1,192),(4448,221,1,206),(4449,221,1,192),(4450,221,1,206),(4451,221,1,192),(4452,221,1,206),(4453,221,5,14),(4454,221,5,15),(4455,221,5,16),(4456,221,5,32),(4457,221,5,33),(4458,221,6,55),(4459,221,6,56),(4460,221,6,62),(4461,221,6,206),(4462,221,6,55),(4463,221,6,56),(4464,221,6,62),(4465,221,6,206),(4466,221,6,55),(4467,221,6,56),(4468,221,6,62),(4469,221,6,206),(4470,221,6,55),(4471,221,6,56),(4472,221,6,62),(4473,221,6,206),(4474,221,6,55),(4475,221,6,56),(4476,221,6,62),(4477,221,6,206),(4478,221,7,34),(4479,221,7,55),(4480,221,7,56),(4481,221,7,61),(4482,221,7,62),(4483,221,7,191),(4484,221,7,199),(4485,221,7,208),(4486,221,7,34),(4487,221,7,55),(4488,221,7,56),(4489,221,7,61),(4490,221,7,62),(4491,221,7,191),(4492,221,7,199),(4493,221,7,208),(4494,221,7,34),(4495,221,7,55),(4496,221,7,56),(4497,221,7,61),(4498,221,7,62),(4499,221,7,191),(4500,221,7,199),(4501,221,7,208),(4502,221,7,34),(4503,221,7,55),(4504,221,7,56),(4505,221,7,61),(4506,221,7,62),(4507,221,7,191),(4508,221,7,199),(4509,221,7,208),(4510,221,7,34),(4511,221,7,55),(4512,221,7,56),(4513,221,7,61),(4514,221,7,62),(4515,221,7,191),(4516,221,7,199),(4517,221,7,208),(4518,221,8,89),(4519,221,8,113),(4520,221,8,171),(4521,221,8,89),(4522,221,8,113),(4523,221,8,171),(4524,221,8,89),(4525,221,8,113),(4526,221,8,171),(4527,221,8,89),(4528,221,8,113),(4529,221,8,171),(4530,221,8,89),(4531,221,8,113),(4532,221,8,171),(4533,222,1,192),(4534,222,1,206),(4535,222,1,192),(4536,222,1,206),(4537,222,1,192),(4538,222,1,206),(4539,222,1,192),(4540,222,1,206),(4541,222,1,192),(4542,222,1,206),(4543,222,1,192),(4544,222,1,206),(4545,222,5,14),(4546,222,5,15),(4547,222,5,16),(4548,222,5,32),(4549,222,5,33),(4550,222,6,55),(4551,222,6,56),(4552,222,6,62),(4553,222,6,206),(4554,222,6,55),(4555,222,6,56),(4556,222,6,62),(4557,222,6,206),(4558,222,6,55),(4559,222,6,56),(4560,222,6,62),(4561,222,6,206),(4562,222,6,55),(4563,222,6,56),(4564,222,6,62),(4565,222,6,206),(4566,222,6,55),(4567,222,6,56),(4568,222,6,62),(4569,222,6,206),(4570,222,6,55),(4571,222,6,56),(4572,222,6,62),(4573,222,6,206),(4574,222,7,34),(4575,222,7,55),(4576,222,7,56),(4577,222,7,61),(4578,222,7,62),(4579,222,7,191),(4580,222,7,199),(4581,222,7,208),(4582,222,7,34),(4583,222,7,55),(4584,222,7,56),(4585,222,7,61),(4586,222,7,62),(4587,222,7,191),(4588,222,7,199),(4589,222,7,208),(4590,222,7,34),(4591,222,7,55),(4592,222,7,56),(4593,222,7,61),(4594,222,7,62),(4595,222,7,191),(4596,222,7,199),(4597,222,7,208),(4598,222,7,34),(4599,222,7,55),(4600,222,7,56),(4601,222,7,61),(4602,222,7,62),(4603,222,7,191),(4604,222,7,199),(4605,222,7,208),(4606,222,7,34),(4607,222,7,55),(4608,222,7,56),(4609,222,7,61),(4610,222,7,62),(4611,222,7,191),(4612,222,7,199),(4613,222,7,208),(4614,222,7,34),(4615,222,7,55),(4616,222,7,56),(4617,222,7,61),(4618,222,7,62),(4619,222,7,191),(4620,222,7,199),(4621,222,7,208),(4622,222,8,89),(4623,222,8,113),(4624,222,8,171),(4625,222,8,89),(4626,222,8,113),(4627,222,8,171),(4628,222,8,89),(4629,222,8,113),(4630,222,8,171),(4631,222,8,89),(4632,222,8,113),(4633,222,8,171),(4634,222,8,89),(4635,222,8,113),(4636,222,8,171),(4637,222,8,89),(4638,222,8,113),(4639,222,8,171),(4640,223,1,192),(4641,223,1,206),(4642,223,1,192),(4643,223,1,206),(4644,223,1,192),(4645,223,1,206),(4646,223,1,192),(4647,223,1,206),(4648,223,1,192),(4649,223,1,206),(4650,223,1,192),(4651,223,1,206),(4652,223,1,192),(4653,223,1,206),(4654,223,5,14),(4655,223,5,15),(4656,223,5,16),(4657,223,5,32),(4658,223,5,33),(4659,223,6,55),(4660,223,6,56),(4661,223,6,62),(4662,223,6,206),(4663,223,6,55),(4664,223,6,56),(4665,223,6,62),(4666,223,6,206),(4667,223,6,55),(4668,223,6,56),(4669,223,6,62),(4670,223,6,206),(4671,223,6,55),(4672,223,6,56),(4673,223,6,62),(4674,223,6,206),(4675,223,6,55),(4676,223,6,56),(4677,223,6,62),(4678,223,6,206),(4679,223,6,55),(4680,223,6,56),(4681,223,6,62),(4682,223,6,206),(4683,223,6,55),(4684,223,6,56),(4685,223,6,62),(4686,223,6,206),(4687,223,7,34),(4688,223,7,55),(4689,223,7,56),(4690,223,7,61),(4691,223,7,62),(4692,223,7,191),(4693,223,7,199),(4694,223,7,208),(4695,223,7,34),(4696,223,7,55),(4697,223,7,56),(4698,223,7,61),(4699,223,7,62),(4700,223,7,191),(4701,223,7,199),(4702,223,7,208),(4703,223,7,34),(4704,223,7,55),(4705,223,7,56),(4706,223,7,61),(4707,223,7,62),(4708,223,7,191),(4709,223,7,199),(4710,223,7,208),(4711,223,7,34),(4712,223,7,55),(4713,223,7,56),(4714,223,7,61),(4715,223,7,62),(4716,223,7,191),(4717,223,7,199),(4718,223,7,208),(4719,223,7,34),(4720,223,7,55),(4721,223,7,56),(4722,223,7,61),(4723,223,7,62),(4724,223,7,191),(4725,223,7,199),(4726,223,7,208),(4727,223,7,34),(4728,223,7,55),(4729,223,7,56),(4730,223,7,61),(4731,223,7,62),(4732,223,7,191),(4733,223,7,199),(4734,223,7,208),(4735,223,7,34),(4736,223,7,55),(4737,223,7,56),(4738,223,7,61),(4739,223,7,62),(4740,223,7,191),(4741,223,7,199),(4742,223,7,208),(4743,223,8,89),(4744,223,8,113),(4745,223,8,171),(4746,223,8,89),(4747,223,8,113),(4748,223,8,171),(4749,223,8,89),(4750,223,8,113),(4751,223,8,171),(4752,223,8,89),(4753,223,8,113),(4754,223,8,171),(4755,223,8,89),(4756,223,8,113),(4757,223,8,171),(4758,223,8,89),(4759,223,8,113),(4760,223,8,171),(4761,223,8,89),(4762,223,8,113),(4763,223,8,171),(4764,224,1,192),(4765,224,1,206),(4766,224,1,192),(4767,224,1,206),(4768,224,1,192),(4769,224,1,206),(4770,224,1,192),(4771,224,1,206),(4772,224,1,192),(4773,224,1,206),(4774,224,1,192),(4775,224,1,206),(4776,224,1,192),(4777,224,1,206),(4778,224,1,192),(4779,224,1,206),(4780,224,5,14),(4781,224,5,15),(4782,224,5,16),(4783,224,5,32),(4784,224,5,33),(4785,224,6,55),(4786,224,6,56),(4787,224,6,62),(4788,224,6,206),(4789,224,6,55),(4790,224,6,56),(4791,224,6,62),(4792,224,6,206),(4793,224,6,55),(4794,224,6,56),(4795,224,6,62),(4796,224,6,206),(4797,224,6,55),(4798,224,6,56),(4799,224,6,62),(4800,224,6,206),(4801,224,6,55),(4802,224,6,56),(4803,224,6,62),(4804,224,6,206),(4805,224,6,55),(4806,224,6,56),(4807,224,6,62),(4808,224,6,206),(4809,224,6,55),(4810,224,6,56),(4811,224,6,62),(4812,224,6,206),(4813,224,6,55),(4814,224,6,56),(4815,224,6,62),(4816,224,6,206),(4817,224,7,34),(4818,224,7,55),(4819,224,7,56),(4820,224,7,61),(4821,224,7,62),(4822,224,7,191),(4823,224,7,199),(4824,224,7,208),(4825,224,7,34),(4826,224,7,55),(4827,224,7,56),(4828,224,7,61),(4829,224,7,62),(4830,224,7,191),(4831,224,7,199),(4832,224,7,208),(4833,224,7,34),(4834,224,7,55),(4835,224,7,56),(4836,224,7,61),(4837,224,7,62),(4838,224,7,191),(4839,224,7,199),(4840,224,7,208),(4841,224,7,34),(4842,224,7,55),(4843,224,7,56),(4844,224,7,61),(4845,224,7,62),(4846,224,7,191),(4847,224,7,199),(4848,224,7,208),(4849,224,7,34),(4850,224,7,55),(4851,224,7,56),(4852,224,7,61),(4853,224,7,62),(4854,224,7,191),(4855,224,7,199),(4856,224,7,208),(4857,224,7,34),(4858,224,7,55),(4859,224,7,56),(4860,224,7,61),(4861,224,7,62),(4862,224,7,191),(4863,224,7,199),(4864,224,7,208),(4865,224,7,34),(4866,224,7,55),(4867,224,7,56),(4868,224,7,61),(4869,224,7,62),(4870,224,7,191),(4871,224,7,199),(4872,224,7,208),(4873,224,7,34),(4874,224,7,55),(4875,224,7,56),(4876,224,7,61),(4877,224,7,62),(4878,224,7,191),(4879,224,7,199),(4880,224,7,208),(4881,224,8,89),(4882,224,8,113),(4883,224,8,171),(4884,224,8,89),(4885,224,8,113),(4886,224,8,171),(4887,224,8,89),(4888,224,8,113),(4889,224,8,171),(4890,224,8,89),(4891,224,8,113),(4892,224,8,171),(4893,224,8,89),(4894,224,8,113),(4895,224,8,171),(4896,224,8,89),(4897,224,8,113),(4898,224,8,171),(4899,224,8,89),(4900,224,8,113),(4901,224,8,171),(4902,224,8,89),(4903,224,8,113),(4904,224,8,171),(4905,225,1,192),(4906,225,1,206),(4907,225,5,14),(4908,225,5,15),(4909,225,5,32),(4910,225,5,33),(4911,225,6,55),(4912,225,6,56),(4913,225,6,62),(4914,225,6,206),(4915,225,7,34),(4916,225,7,55),(4917,225,7,56),(4918,225,7,61),(4919,225,7,62),(4920,225,7,191),(4921,225,7,199),(4922,225,7,208),(4923,225,8,89),(4924,225,8,113),(4925,226,1,192),(4926,226,1,206),(4927,226,5,14),(4928,226,5,15),(4929,226,5,32),(4930,226,5,33),(4931,226,6,55),(4932,226,6,56),(4933,226,6,62),(4934,226,6,206),(4935,226,7,34),(4936,226,7,55),(4937,226,7,56),(4938,226,7,61),(4939,226,7,62),(4940,226,7,191),(4941,226,7,199),(4942,226,7,208),(4943,226,8,89),(4944,226,8,113),(4945,227,1,192),(4946,227,1,206),(4947,227,5,14),(4948,227,5,15),(4949,227,5,32),(4950,227,5,33),(4951,227,6,55),(4952,227,6,56),(4953,227,6,62),(4954,227,6,206),(4955,227,7,34),(4956,227,7,55),(4957,227,7,56),(4958,227,7,61),(4959,227,7,62),(4960,227,7,191),(4961,227,7,199),(4962,227,7,208),(4963,227,8,89),(4964,227,8,113);
/*!40000 ALTER TABLE `issues` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `news`
--

DROP TABLE IF EXISTS `news`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `news` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) DEFAULT NULL,
  `content` varchar(256) DEFAULT NULL,
  `date` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `news`
--

LOCK TABLES `news` WRITE;
/*!40000 ALTER TABLE `news` DISABLE KEYS */;
INSERT INTO `news` VALUES (1,'Release 0.1','HAECHI is now open source','02.03.2019'),(2,'Release 0.2','Added experimental rules','17.03.2019'),(3,'Release 0.3','Added a new rule : TransferEther','11.04.2019'),(4,'Release 0.4','Added a new rule : Reentrancy','16.05.2019'),(5,'Release 0.5','Added a new rule : MultipleInheritance','01.09.2019'),(6,'Release 0.6','Launched HAECHI Web Service','26.10.2019');
/*!40000 ALTER TABLE `news` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `vulnerability`
--

DROP TABLE IF EXISTS `vulnerability`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `vulnerability` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) DEFAULT NULL,
  `content` varchar(256) DEFAULT NULL,
  `recommendation` varchar(128) DEFAULT NULL,
  `example` text,
  `links` varchar(64) DEFAULT NULL,
  `implement` int(11) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `vulnerability`
--

LOCK TABLES `vulnerability` WRITE;
/*!40000 ALTER TABLE `vulnerability` DISABLE KEYS */;
INSERT INTO `vulnerability` VALUES (1,'DoSAttack','Potential vulnerability to DoS attack',NULL,NULL,NULL,1),(2,'None Access Modifier','Please specify Access Modifier explicitly',NULL,NULL,NULL,1),(3,'Overflow','Note the operation of integer variables',NULL,NULL,NULL,0),(4,'Underflow','Note the operation of integer variables',NULL,NULL,NULL,0),(5,'Reentrancy','Potential vulnerability to Reentrancy attack',NULL,NULL,NULL,1),(6,'Transfer Ether','Incorrect function usage in Ether transmission, Use transfer() instead',NULL,NULL,NULL,1),(7,'Use tx.origin','Potential vulnerability to tx.origin attack',NULL,NULL,NULL,1),(8,'Multiple Inheritance','Do not write multiple inheritance',NULL,NULL,NULL,1);
/*!40000 ALTER TABLE `vulnerability` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-11-21  6:26:32
